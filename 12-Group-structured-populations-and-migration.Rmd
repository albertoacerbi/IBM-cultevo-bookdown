
# Group structured populations and migration

Many simulations assume well-mixed populations, that is, populations of individuals that have an equal chance of encountering each other. In the previous chapter, we have looked at the effects of structured interactions on the transmission of cultural traits. Both, structured and unstructured populations, can be good approximations to the real world, depending on the context and research question. In this chapter, we will look at structured populations, a combination of the two. That is, a large population of individuals is divided into sub-populations, where individuals _within_ a sub-population are equally likely to encounter each other, whereas encounter frequency _between_ sub-populations is significantly reduced. As such learning only occurs within each sub-population. However, individuals can migrate between sub-populations, bringing along their version of a cultural trait. 

In this chapter, we will simulate this movement between sub-populations to study its effect on the transmission of a socially acquired behaviour. We model a population of size $n$, with $s$ sub-populations, and $b$ instances of a behavioural trait. For most of this chapter, we assume that there are two versions of the behaviour, for example, two individuals greet each other either with a handshake or with a hug. You will see that there are many opportunities to alter the model (have more sub-populations, behaviours, learning events, etc.). 

We will start very simply with one large population where individuals acquire a behavioural trait from a random individual in their population, and then add layers to the model. Let us set up a population:

```{r 12.1}
n <- 100
b <- 2

behaviours <- sample(x=b, size=n, replace=TRUE)
behaviours[1:10]
table(behaviours)
```

Because we are only interested which instance of a particular behaviour an individual expresses, each individual can be fully described by its behaviour, and so, we can represent the entire population as a vector of expressed behaviours (`behaviours`). 

Everyone in our populations, is constantly exhibiting their behaviour. Occasionally, one of the individuals will copy the behaviour of another individual. To simulate this behavioural updating, we select two random individuals (an observer and a model) and then copy the model's behaviour into the the observer's entry. We wrap a loop around these two steps to simulate repeated updating events and add a record variable to store the frequency of each of the behaviours.

```{r 12.2}
t <- 1000
recbehav <- matrix(NA, nrow=t, ncol=b)

for(timestep in 1:t){
  # choose a random observer and a random individual to observe 
  observer_model <- sample(x=n, size=2, replace=F)
  # let observer acquire trait from model
  behaviours[ observer_model[1] ] <- behaviours[ observer_model[2] ]
  # record the frequency of each trait in each timestep
  recbehav[timestep,] <- table(behaviours)
}
```

Now, we can plot the frequency of each behaviour over time, which we recorded in the `recbehav` matrix.

```{r 12.3}
library(ggplot2)
library(reshape2)
recbehav_d <- melt(recbehav)
colnames(recbehav_d) <- c("time", "behaviour","freq")

ggplot(recbehav_d) + geom_line(aes(x=time, y=freq/n, col=factor(behaviour))) + scale_y_continuous(limits=c(0,1))
```

As we would have expected from an unbiased transmission, the frequency of the two traits will move around $0.5$. For smaller populations, more traits, or longer time drift will lead to the exclusion of one of the traits. We can test this by using a much smaller population. To do so, let us first wrap the simulation in a function called `migrationModel()`. 

```{r 12.4}
migrationModel <- function(POPSIZE, NBEHAVIOUR, NTIMESTEPS){
  behaviours <- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE)
  recbehav <- matrix(NA, nrow=NTIMESTEPS, ncol=NBEHAVIOUR)
  
  for(timestep in 1:NTIMESTEPS){
    # choose a random observer and a random individual to observe 
    observer_model <- sample(x=POPSIZE, size=2, replace=F)
    # let observer acquire trait from model
    behaviours[ observer_model[1] ] <- behaviours[ observer_model[2] ]
    recbehav[timestep,] <- as.numeric(table(behaviours)) / POPSIZE
  }
  return(recbehav)
}
```

The function makes it easy to quickly run simulations with different input parameters. Here, we run the simulation with a population size of $n=20$:

```{r 12.5}
# run simulation
set.seed(3)
res <- migrationModel(POPSIZE=20, NBEHAVIOUR=2, NTIMESTEPS=1000)
# turn results matrix into long format
recbehav_d <- melt(res)
# add descriptive column names
colnames(recbehav_d) <- c("time", "behaviour","freq")
# plot results
ggplot(recbehav_d) + 
  geom_line(aes(x=time, y=freq, col=factor(behaviour))) + 
  scale_y_continuous(limits=c(0,1))
```

As you can see, the two behaviours meander until, by chance, behaviour $1$ is completely replaced by behaviour $2$. 


## Subdivided population
Now let us assume that the population we are looking at divided into two sub-populations, here `clusters`. We will keep track which individual belongs to which cluster and then record the frequency of one of the behaviours, $p$, (the frequency of the other behaviour, $q$, is simply $1-p$) in each cluster. 

```{r 12.6}
migrationModel <- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){
  cluster <- sample(x=NPOP, size=POPSIZE, replace=TRUE)
  behaviours <- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE)
  recbehav <- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP)
  
  for(timestep in 1:NTIMESTEPS){
    # choose a random observer and a random individual to observe 
    observer_model <- sample(x=POPSIZE, size=2, replace=F)
    # let observer acquire trait from model
    behaviours[ observer_model[1] ] <- behaviours[ observer_model[2] ]
    # record the relative frequency of behaviour 1 for each cluster
    recbehav[timestep,] <- unlist(lapply(1:NPOP, function(x) sum( behaviours[cluster==x]==1 ) / sum(cluster==x)))
  }
  
  recbehav_d <- melt(recbehav)
  colnames(recbehav_d) <- c("time", "cluster","freq")
  return(recbehav_d)
}

# run simulation
set.seed(3)
res <- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000)

# plot results
ggplot(res) + 
  geom_line(aes(x=time, y=freq, col=factor(cluster))) + 
  scale_y_continuous(limits=c(0,1)) + 
  ylab("Relative frequency of behaviour 1")
```

Running this code repeatedly will show you two things. First, on average the frequency of each behaviour will still be around 0.5, and second that the frequency changes are highly correlated between the two sub-populations. This is an expected behaviour because with the current version of our model, individuals do not distinguish between or have different access to individuals of either cluster. 

Now, let us assume that members of a cluster preferentially learn from others with in their cluster. This might be the case where individuals spent most of their time in their sub-populations. To make sure that we choose an observer and a model from the same cluster we can use the `prob` argument in the `sample()`. This argument gives a weight (or probability) with which an element of a provided set is chosen. By default each element has a weight of $1$, and thus is equally likely to be selected. To limit our scope to individuals within the same cluster, we can simply set the weight to $0$ for all individauls that are in a different cluster. And so, we first select a cluster and then choose two individauls from that cluster to be our observer and model. We will add an `if` statement to make sure that there are at least two individuals in the cluster:

```{r}
npop <- 2
n <- 50
b <- 2
t <- 1000

migrationModel <- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){
  cluster <- sample(x=NPOP, size=POPSIZE, replace=TRUE)
  behaviours <- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE)
  recbehav <- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP)
  
  for(timestep in 1:NTIMESTEPS){
    # choose a random cluster
    clusterid <- sample(npop, 1)
    # if there are at least two individuals in this cluster
    if(sum(cluster==clusterid)>1){
      # choose a random observer and a random individual to observe within the same cluster 
      observer_model <- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1)
      behaviours[ observer_model[1] ] <- behaviours[ observer_model[2] ]
    }
    recbehav[timestep,] <- unlist(lapply(1:npop, function(x) sum( behaviours[cluster==x]==1 ) / sum(cluster==x)))
  }
  
  recbehav_d <- melt(recbehav)
  colnames(recbehav_d) <- c("time", "cluster","freq")
  return(recbehav_d)
}

res <- migrationModel(NPOP=npop, POPSIZE=n, NBEHAVIOUR=b, NTIMESTEPS=t)
ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab("Relative frequency of behaviour 1")
```

When you run this simulation repeatedly, you will see that sometimes one of the behaviours gets lost in one, both, or neither of the clusters. Because in this iteration of our simulation there are no interactions between clusters, we essentially simulating two independent populations. You can see that this is the case when 

Let's test that these clusters are in fact independent by fixing each population to one of the two behaviours:

```{r}
migrationModel <- function(NPOP, POPSIZE, NTIMESTEPS){
  traits <- rep(1:NPOP, each=POPSIZE/NPOP)
  cluster <- rep(1:NPOP, each=POPSIZE/NPOP)
  recbehav <- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP)
  
  for(timestep in 1:NTIMESTEPS){
    # choose a random cluster
    clusterid <- sample(NPOP, 1)
    # if there are at least two individuals in this cluster
    if(sum(cluster==clusterid)>1){
      # choose a random observer and a random individual to observe within the same cluster 
      observer_model <- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1)
      # let observer acquire trait from model
      traits[ observer_model[1] ] <- traits[ observer_model[2] ]
    }
    recbehav[timestep,] <- unlist(lapply(1:NPOP, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x)))
  }
  
  recbehav_d <- melt(recbehav)
  colnames(recbehav_d) <- c("time", "cluster","freq")
  return(recbehav_d)
}

res <- migrationModel(NPOP=2, POPSIZE=50, NTIMESTEPS=100)
ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab("Relative frequency of behaviour 1")
```

Now, let us change the code to allow migration between the clusters. 

* real migration (change cluster id)
* cultural migration (learn from a different cluster also)

```{r}
migrationModel <- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS, MIGRATION){
  # traits <- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE)
  # cluster <- sample(x=NPOP, size=POPSIZE, replace=TRUE)
  traits <- rep(1:NBEHAVIOUR, each=POPSIZE/NPOP)
  cluster <- rep(sample(NPOP), each=POPSIZE/NPOP)
  recbehav <- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP)
  for(timestep in 1:NTIMESTEPS){
    # choose a random cluster
    clusterid <- sample(npop, 1)
    # if there are at least two individuals in this cluster
    if(sum(cluster==clusterid)>1){
      # choose a random observer and a random individual to observe within the same cluster 
      observer_model <- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1)
      # let observer acquire trait from model
      traits[ observer_model[1] ] <- traits[ observer_model[2] ]
    }
    # migrate
    if(runif(1,0,1) <= MIGRATION){
      cluster[ observer_model[1] ] <- sample(npop, 1)
    }
    recbehav[timestep,] <- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x)))
  }
  
  recbehav_d <- melt(recbehav)
  colnames(recbehav_d) <- c("time", "cluster","freq")
  return(recbehav_d)
}
```

If we leave migration at zero, we still find that the behaviours in the two clusters are independent from each other:
```{r}
res <- migrationModel(NPOP=2, POPSIZE=50, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=0)
ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab("Relative frequency of behaviour 1")
```

At the other extreme (migration equal to 1), we find that the frequency of the behaviours becomes correlated as more and more individuals keep moving between the clusters. It is as if there were not clusters. 
```{r}
res <- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=1)
ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab("Relative frequency of behaviour 1")
```

For rare migration, we can find occassional changes in the frequency but it usually bounces back. 
```{r}
res <- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=0.01)
ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab("Relative frequency of behaviour 1")
```


Now, let's check how correlated the groups are. To do so, run repeatedly (100) and check correlation between end points of the two populations, do this for different migration rates. 

```{r}
repeatedRun <- do.call("rbind", 
  lapply(1:100, function(run){
    # run individual simulation
    res <- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=.5)
    # return only the frequency for each cluster at the last time step
    resLast <- res[res[,"time"]==max(res[,"time"]),"freq"]
    return(resLast)
  })
  )

ggplot(as.data.frame(repeatedRun)) + 
  geom_point(aes(x=V1, y=V2)) + xlab("Frequency in cluster 1") + ylab("Frequency in cluster 2")

mean(abs(repeatedRun[,1]-repeatedRun[,2]))
```

let's change the function so that the model will return the analysis right away

```{r}
migrationModelAnalysed <- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS, MIGRATION, REPETITIONS){
  recbehavFreq <- matrix(NA, ncol=NPOP, nrow=REPETITIONS)
  for(repetitions in 1:REPETITIONS){
    traits <- rep(1:NBEHAVIOUR, each=POPSIZE/NPOP)
    cluster <- rep(sample(NPOP), each=POPSIZE/NPOP)
    for(timestep in 1:NTIMESTEPS){
      # choose a random cluster
      clusterid <- sample(npop, 1)
      # if there are at least two individuals in this cluster
      if(sum(cluster==clusterid)>1){
        # choose a random observer and a random individual to observe within the same cluster 
        observer_model <- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1)
        # let observer acquire trait from model
        traits[ observer_model[1] ] <- traits[ observer_model[2] ]
      }
      # migrate
      if(runif(1,0,1) <= MIGRATION){
        cluster[ observer_model[1] ] <- sample(npop, 1)
      }
    }
    recbehavFreq[repetitions, ] <- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) 
  }

  return(
  data.frame(migration=MIGRATION, 
             # rsq      = cor(x=recbehavFreq[,1], y=recbehavFreq[,2])^2,
             absdiff  = mean(abs(recbehavFreq[,1]-recbehavFreq[,2])))
  )
}

migrationModelAnalysed(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=.125, REPETITIONS=2)
```

Now we can easily run this simulation for various different values of migration rates

```{r}
repeatedRun <- do.call("rbind",
  lapply(seq(from=0, to=1, by=0.05), function(migration){
  # lapply(runif(n=50, min=0, max=1), function(migration){
    migrationModelAnalysed(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=migration, REPETITIONS=20)
  })
  )

ggplot(repeatedRun) + 
  geom_point(aes(x=migration, y=absdiff)) + xlab("Migration rate") + ylab("Average frequency difference between clusters")
```







## Summary of the model

This model ...

Finally, suggest that this model can be extended to accomodate different population structures. Here, we have only looked at symeetric connectiongs between populations (all sub-populations are connected). But the structure could also be a line, a circle, or a star. The only thing we would need to change for that is the probability vector in the sample function of the migration part. Thus, not choosing randomly among all sub-populations, but among those that share a connection with the cluster the individual is in.

***

## Analytical appendix

Todo, or omit. 

***

## Further reading


Maybe a simpler example 
where we have three populations and three behaviours (shake left hand (red), right hand (red), clap both hands together). 
Individuals are replaced and copy behaviour of the majory of N samples within their group
That leads to stable greeting traditions within each group
(display populations as network, colour nodes based on behaviour)

If we now allow migration (after learning) between groups, stability will depend on strength of migration (if we allowed migrationi before learning then individuals wouldn't be 'tradition carrier')

If we go all the way up to migration $= 1$, we find that the subgroups behave like one big group

Maybe suggest as additional examples (but not exercise here?): 
* In addition to A--B, B--C, A--C, we can also test A--B, B--C (line) to see what happens to the fate of the central population with two neighbours
* Finally, we can use the same set up (A--B, B--C) with larger flow towards B and less towards C


