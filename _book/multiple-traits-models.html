<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>6 Multiple traits models | Individual-based models of cultural evolution</title>
  <meta name="description" content="A minimal working structure for the book" />
  <meta name="generator" content="bookdown 0.11 and GitBook 2.6.7" />

  <meta property="og:title" content="6 Multiple traits models | Individual-based models of cultural evolution" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A minimal working structure for the book" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="6 Multiple traits models | Individual-based models of cultural evolution" />
  
  <meta name="twitter:description" content="A minimal working structure for the book" />
  

<meta name="author" content="Alberto Acerbi" />
<meta name="author" content="Alex Mesoudi" />
<meta name="author" content="Marco Smolla" />


<meta name="date" content="2019-09-11" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="horizontal-vertical-and-oblique-transmission-.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Individual-based models of cultural evolution</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a></li>
<li class="part"><span><b>Basics</b></span><ul>
<li class="chapter" data-level="0.1" data-path="index.html"><a href="index.html#initialising-the-simulation"><i class="fa fa-check"></i><b>0.1</b> Initialising the simulation</a></li>
<li class="chapter" data-level="0.2" data-path="index.html"><a href="index.html#execute-generation-turn-over-many-times"><i class="fa fa-check"></i><b>0.2</b> Execute generation turn-over many times</a></li>
<li class="chapter" data-level="0.3" data-path="index.html"><a href="index.html#plotting-the-model-results"><i class="fa fa-check"></i><b>0.3</b> Plotting the model results</a></li>
<li class="chapter" data-level="0.4" data-path="index.html"><a href="index.html#write-a-function-to-wrap-the-model-code"><i class="fa fa-check"></i><b>0.4</b> Write a function to wrap the model code</a></li>
<li class="chapter" data-level="0.5" data-path="index.html"><a href="index.html#run-several-independent-simulations-and-plot-their-results"><i class="fa fa-check"></i><b>0.5</b> Run several independent simulations and plot their results</a></li>
<li class="chapter" data-level="0.6" data-path="index.html"><a href="index.html#varying-initial-conditions"><i class="fa fa-check"></i><b>0.6</b> Varying initial conditions</a></li>
<li class="chapter" data-level="0.7" data-path="index.html"><a href="index.html#summary-of-the-model"><i class="fa fa-check"></i><b>0.7</b> Summary of the model</a></li>
<li class="chapter" data-level="0.8" data-path="index.html"><a href="index.html#analytical-appendix"><i class="fa fa-check"></i><b>0.8</b> Analytical appendix</a></li>
<li class="chapter" data-level="0.9" data-path="index.html"><a href="index.html#further-readings"><i class="fa fa-check"></i><b>0.9</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html"><i class="fa fa-check"></i><b>1</b> Unbiased and biased mutation</a><ul>
<li class="chapter" data-level="1.1" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#unbiased-mutation"><i class="fa fa-check"></i><b>1.1</b> Unbiased mutation</a></li>
<li class="chapter" data-level="1.2" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#biased-mutation"><i class="fa fa-check"></i><b>1.2</b> Biased mutation</a></li>
<li class="chapter" data-level="1.3" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#summary-of-the-model-1"><i class="fa fa-check"></i><b>1.3</b> Summary of the model</a></li>
<li class="chapter" data-level="1.4" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#analytical-appendix-1"><i class="fa fa-check"></i><b>1.4</b> Analytical appendix</a></li>
<li class="chapter" data-level="1.5" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#further-readings-1"><i class="fa fa-check"></i><b>1.5</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html"><i class="fa fa-check"></i><b>2</b> Biased transmission (direct bias)</a><ul>
<li class="chapter" data-level="2.1" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#strenght-of-selection"><i class="fa fa-check"></i><b>2.1</b> Strenght of selection</a></li>
<li class="chapter" data-level="2.2" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#summary-of-the-model-2"><i class="fa fa-check"></i><b>2.2</b> Summary of the model</a></li>
<li class="chapter" data-level="2.3" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#analytical-appendix-2"><i class="fa fa-check"></i><b>2.3</b> Analytical appendix</a></li>
<li class="chapter" data-level="2.4" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#further-readings-2"><i class="fa fa-check"></i><b>2.4</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html"><i class="fa fa-check"></i><b>3</b> Biased transmission (indirect bias: frequency)</a><ul>
<li class="chapter" data-level="3.1" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html#the-logic-of-conformity"><i class="fa fa-check"></i><b>3.1</b> The logic of conformity</a></li>
<li class="chapter" data-level="3.2" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html#testing-conformist-transmission"><i class="fa fa-check"></i><b>3.2</b> Testing conformist transmission</a></li>
<li class="chapter" data-level="3.3" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html#summary-of-the-model-3"><i class="fa fa-check"></i><b>3.3</b> Summary of the model</a></li>
<li class="chapter" data-level="3.4" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html#analytical-appendix-3"><i class="fa fa-check"></i><b>3.4</b> Analytical appendix</a></li>
<li class="chapter" data-level="3.5" data-path="biased-transmission-indirect-bias-frequency.html"><a href="biased-transmission-indirect-bias-frequency.html#further-readings-3"><i class="fa fa-check"></i><b>3.5</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html"><i class="fa fa-check"></i><b>4</b> Biased transmission (indirect bias: demonstrator)</a><ul>
<li class="chapter" data-level="4.1" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html#a-simple-demonstrator-bias"><i class="fa fa-check"></i><b>4.1</b> A simple demonstrator bias</a></li>
<li class="chapter" data-level="4.2" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html#predicting-the-winning-trait"><i class="fa fa-check"></i><b>4.2</b> Predicting the ‘winning’ trait</a></li>
<li class="chapter" data-level="4.3" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html#summary-of-the-model-4"><i class="fa fa-check"></i><b>4.3</b> Summary of the model</a></li>
<li class="chapter" data-level="4.4" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html#analytical-appendix-4"><i class="fa fa-check"></i><b>4.4</b> Analytical appendix</a></li>
<li class="chapter" data-level="4.5" data-path="biased-transmission-indirect-bias-demonstrator.html"><a href="biased-transmission-indirect-bias-demonstrator.html#further-readings-4"><i class="fa fa-check"></i><b>4.5</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="horizontal-vertical-and-oblique-transmission-.html"><a href="horizontal-vertical-and-oblique-transmission-.html"><i class="fa fa-check"></i><b>5</b> Horizontal, vertical, and oblique transmission.</a><ul>
<li class="chapter" data-level="5.1" data-path="horizontal-vertical-and-oblique-transmission-.html"><a href="horizontal-vertical-and-oblique-transmission-.html#analytical-appendix-5"><i class="fa fa-check"></i><b>5.1</b> Analytical appendix</a></li>
<li class="chapter" data-level="5.2" data-path="horizontal-vertical-and-oblique-transmission-.html"><a href="horizontal-vertical-and-oblique-transmission-.html#further-readings-5"><i class="fa fa-check"></i><b>5.2</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html"><i class="fa fa-check"></i><b>6</b> Multiple traits models</a><ul>
<li class="chapter" data-level="6.1" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#introducing-innovations"><i class="fa fa-check"></i><b>6.1</b> Introducing innovations</a></li>
<li class="chapter" data-level="6.2" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#optimising-the-code"><i class="fa fa-check"></i><b>6.2</b> Optimising the code</a></li>
<li class="chapter" data-level="6.3" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#the-distribution-of-popularity"><i class="fa fa-check"></i><b>6.3</b> The distribution of popularity</a></li>
<li class="chapter" data-level="6.4" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#summary-of-the-model-5"><i class="fa fa-check"></i><b>6.4</b> Summary of the model</a></li>
<li class="chapter" data-level="6.5" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#analytical-appendix-6"><i class="fa fa-check"></i><b>6.5</b> Analytical appendix</a></li>
<li class="chapter" data-level="6.6" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#further-readings-6"><i class="fa fa-check"></i><b>6.6</b> Further readings</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Individual-based models of cultural evolution</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="multiple-traits-models" class="section level1">
<h1><span class="header-section-number">6</span> Multiple traits models</h1>
<p>In all the scenarios we considered so far, individuals could posses one of two cultural traits, <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>. This is a useful simplification, and it represents cases in which cultural traits can be modeled as binary choices, such as being in favour or against a particular policy, choosing between Beatles and Rolling Stones (and no one else!), eating meat or not, and similar. In other cases, however, there are many options: there are many books to read, movies to watch, and, despite our Beatles and Rolling Stones example, many musical bands one can choose to listen to. What does it happen when we copy others’ choices? To simplfy, we are again assuming unbiased copying as in the [first chapter][Unbiased transmission]: all traits are equivalent and we do not copy preferentially from any individual, but just pick them at random.</p>
<p>The first modification we need to do in the code concerns how traits are represented. Since we have an undetermined number of possible traits we can not use the two letters <span class="math inline">\(A\)</span> abd <span class="math inline">\(B\)</span>, but we will use instead numbers, so that traits will be now referred as trait “1”, trait “2”, trait “2”, etc. To start with, we can initliase each individual with a trait randomly chosen between “1” and “100”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre></div>
<pre><code>## ── Attaching packages ────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ──</code></pre>
<pre><code>## ✔ ggplot2 3.2.1     ✔ purrr   0.3.2
## ✔ tibble  2.1.3     ✔ dplyr   0.8.1
## ✔ tidyr   0.8.3     ✔ stringr 1.4.0
## ✔ readr   1.3.1     ✔ forcats 0.4.0</code></pre>
<pre><code>## ── Conflicts ───────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">111</span>)
N &lt;-<span class="st"> </span><span class="dv">100</span>
population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))</code></pre></div>
<p>As usual, you can inspect the <code>population</code> tibble by writing its name.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">population</code></pre></div>
<pre><code>## # A tibble: 100 x 1
##    trait
##    &lt;int&gt;
##  1    60
##  2    73
##  3    38
##  4    52
##  5    38
##  6    42
##  7     2
##  8    54
##  9    44
## 10    10
## # … with 90 more rows</code></pre>
<p>The basic code of the simulation is similar to the code in the [first chapter][Unbiased transmission], but what the <strong>output</strong> should be? Until now, we just needed to save the freuquency of one of the two trait, but now we need the frequencies of all <em>N</em> traits to have an idea of what happens in the simulation.</p>
<p>Another modification in the code above concerns how we measure the frequency of the traits in each generation. The function <code>hist()</code>, as the name suggests, is generally used to plot an histogram of the data. However, it can be used, adding the argument <code>plot = FALSE</code>, to only calculate what we would need for an histogram, without producing the graph. Among the outputs produced, <code>density</code> gives the relative frequencies of the binned data, which is what we are interested in.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multiple_traits &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max) {
  
  output &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">as.factor</span>(<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>N, <span class="dt">each =</span> t_max)), <span class="dt">generation =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>t_max, N), <span class="dt">p =</span> <span class="kw">rep</span>(<span class="ot">NA</span>, t_max <span class="op">*</span><span class="st"> </span>N))

  population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))
  <span class="co"># create first generation</span>
  
  output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">hist</span>(population<span class="op">$</span>trait, <span class="dv">0</span><span class="op">:</span>N, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density
  <span class="co"># add first generation&#39;s p for all traits</span>

  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {
    previous_population &lt;-<span class="st"> </span>population <span class="co"># copy individuals to previous_population tibble</span>

    population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))    <span class="co"># randomly copy from previous generation</span>

    output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span>t, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">hist</span>(population<span class="op">$</span>trait, <span class="dv">0</span><span class="op">:</span>N, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density <span class="co"># get p for all traits and put it into output slot for this generation t</span>
  }
  output <span class="co"># export data from function</span>
}</code></pre></div>
<p>Finally, the function to plot the output is similar to what we have already done when plotting multiple runs, with the difference that now the colored lines do not represent different runs, but different traits, as indicated below by <code>aes(colour = trait)</code>. We also need to specify that traits should not be interpreted The new line <code>theme(legend.position = &quot;none&quot;)</code> simply tells to not include the legends in the graph, as it is not informative, and it would show 100 colors, one for each trait.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plot_multiple_traits &lt;-<span class="st"> </span><span class="cf">function</span>(data_model) {
  <span class="kw">ggplot</span>(<span class="dt">data =</span> data_model, <span class="kw">aes</span>(<span class="dt">y =</span> p, <span class="dt">x =</span> generation)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> trait)) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>)
}</code></pre></div>
<p>As usual, we can call the function and see what happens:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">200</span>)
<span class="kw">plot_multiple_traits</span>(data_model)</code></pre></div>
<p><img src="_main_files/figure-html/7.5-1.png" width="672" /></p>
<p>Only one trait is still present at the end of the simulation. In general, only one or two traits are still present in the population after 200 generations, and, if we increase <span class="math inline">\(t_\text{max}\)</span> for example to 1000, virtually all runs end up with only a single trait reaching fixation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">200</span>)
<span class="kw">plot_multiple_traits</span>(data_model)</code></pre></div>
<p><img src="_main_files/figure-html/7.6-1.png" width="672" /></p>
<p>This is similar to what we saw when considering the analogous situation with only two traits, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>: with unbiased copying and relative small populations, drift is a powerful force, that quickly erodes cultural diversity.</p>
<p>As we already discussed, increasing <span class="math inline">\(N\)</span> limits the effect of drift. You can experiment with various values for <span class="math inline">\(N\)</span> and <span class="math inline">\(t_\text{max}\)</span>. However, the general point is that variation is gradually lost in all cases. How can we counterbalance the homogenizing effect that drift has in small and isolated population, such as the one we are simulating?</p>
<div id="introducing-innovations" class="section level2">
<h2><span class="header-section-number">6.1</span> Introducing innovations</h2>
<p>An option is to introduce new traits with individual innovations. We can imagine that, at each time step, a proportion of individuals, <span class="math inline">\(\mu\)</span> (we use the same notation that we used for mutation in <a href="unbiased-and-biased-mutation.html#unbiased-and-biased-mutation">chapter 2</a>), introduces a new trait in the population. The remaining proportion of individuals, <span class="math inline">\(1-\mu\)</span> copy at random from others, as before. We can start with a small value, such as <span class="math inline">\(\mu=0.01\)</span>. Since <span class="math inline">\(N=100\)</span>, this means that at each generation, on average, one new trait will be introduced in the population.</p>
<p>Let’s see how we can write what happens at each generation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mu &lt;-<span class="st"> </span><span class="fl">0.01</span>

last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) <span class="co"># record what is the last trait introduced in the population</span>

previous_population &lt;-<span class="st"> </span>population <span class="co"># copy the population tibble to previous_population tibble</span>

population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  <span class="co"># randomly copy from previous generation&#39;s individuals</span>

innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) <span class="co"># select the innovators</span>

population[innovators,]<span class="op">$</span>trait &lt;-<span class="st"> </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="co"># replace innovators&#39; traits with new traits</span></code></pre></div>
<p>There are two modifications here. First, we need to select who are the innovators. For that, we use again the function <code>sample()</code>, biased by <span class="math inline">\(\mu\)</span>, picking <span class="math inline">\(TRUE\)</span> (corresponding to be an innovator) or <span class="math inline">\(FALSE\)</span> (keeping the copied cultural trait) for <span class="math inline">\(N\)</span> times.</p>
<p>Second, we need to keep track of the new introduced traits. In order to do so, we record at the beginning of each generation what is the “name” of the last trait introduced (at the beginning, with <span class="math inline">\(N=100\)</span>, it will be “100”, as we initialise each individual of the population with a different trait). When new traits are introduced, we call them with consecutive numbers: the first new traits will be called “101”, the second “102” and so on.</p>
<p>We can now, as usual, wrap everything in a function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multiple_traits_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max, mu) {
  max_traits &lt;-<span class="st"> </span>N <span class="op">+</span><span class="st"> </span>N <span class="op">*</span><span class="st"> </span>mu <span class="op">*</span><span class="st"> </span>t_max

  output &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">as.factor</span>(<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>max_traits, <span class="dt">each =</span> t_max)), <span class="dt">generation =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>t_max, max_traits), <span class="dt">p =</span> <span class="kw">rep</span>(<span class="ot">NA</span>, t_max <span class="op">*</span><span class="st"> </span>max_traits))

  population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))
  <span class="co"># create first generation</span>
  
  output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">hist</span>(population<span class="op">$</span>trait, <span class="dv">0</span><span class="op">:</span>N, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density
  <span class="co"># add first generation&#39;s p for all traits</span>

  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {
    last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) <span class="co"># record what is the last trait introduced in the population</span>

    previous_population &lt;-<span class="st"> </span>population <span class="co"># copy individuals to previous_population tibble</span>

    population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  <span class="co"># randomly copy from previous generation&#39;s individuals</span>
    <span class="co"># randomly copy from previous generation</span>

    innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) <span class="co"># select the innovators</span>
    <span class="cf">if</span> ((last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="op">&lt;</span><span class="st"> </span>max_traits) {  
      <span class="cf">if</span>( <span class="kw">sum</span>(innovators) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){
        population[innovators,]<span class="op">$</span>trait &lt;-<span class="st"> </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="co"># replace innovators&#39; traits with new traits</span>
      }
    }
    output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span>t, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">hist</span>(population<span class="op">$</span>trait, <span class="dv">0</span><span class="op">:</span>max_traits, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density <span class="co"># get p for all traits and put it into output slot for this generation t</span>
  }
  output <span class="co"># export data</span>
}</code></pre></div>
<p>You should now be familiar with more or less everything within this function, with one exception: the introduction of the new quantity <em>max_traits</em>. This is a trick we are using to avoid making the code too heavy to run. Our <code>output</code> tibble, as you remember, record all the frequencies of all traits. When programming, a good rule-of-thumb is to avoid to modify dynamically the size of your data structures, such as, for example, adding new rows to a pre-existing tibble, as in our case. In our simulation, at every generation, there is some probability that a new trait will be introduced so that, as a consequence, we would need to add new rows in the <code>output</code> tibble to record its frequency. To avoid this, we are creating a bigger tibble from the beginning, with rows for many possible new traits. How many is ‘many’? We do not know, but an estimate is that we will need space for the initial traits (<span class="math inline">\(N\)</span>), plus around <span class="math inline">\(N\mu\)</span> traits for each generation. To be sure to not exceed this number, we wrapped the innovation instruction in the <code>if ((last_trait + sum(innovators)) &lt; max_traits)</code> control. As a consequence, it is possible that in some runs, in the very last generations, innovations will not be permitted. For many purposes, this does not change the outcome of the simulation, and for the time being is better than modify dynamically our <code>output</code>.</p>
<p>Let’s now run the function with an innovation rate <span class="math inline">\(\mu=0.01\)</span>, again with a population of 100 individuals, and for 200 generations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">200</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)
<span class="kw">plot_multiple_traits</span>(data_model)</code></pre></div>
<p><img src="_main_files/figure-html/7.9-1.png" width="672" /></p>
<p>There should be now more traits at non-zero frequency at the end of the simulation that what happened when innovations were not possible. We can actually check the exact number, by inspecting how many frequencies higher than 0 are in the last row of our matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">filter</span>(data_model, generation<span class="op">==</span><span class="dv">200</span>)<span class="op">$</span>p <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</code></pre></div>
<pre><code>## [1] 10</code></pre>
<p>What happens if we increase the number of generations, or time steps, to 1000, as we did before?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)
<span class="kw">plot_multiple_traits</span>(data_model)</code></pre></div>
<p><img src="_main_files/figure-html/7.11-1.png" width="672" /></p>
<p>As you can see in the plot, there should still be various traits that have frequencies higher than 0, even after 1000 generations. Again, we can check it</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">filter</span>(data_model, generation<span class="op">==</span><span class="dv">1000</span>)<span class="op">$</span>p <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</code></pre></div>
<pre><code>## [1] 10</code></pre>
<p>Innovation, in sum, allows the maintenance of variation even in small populations.</p>
</div>
<div id="optimising-the-code" class="section level2">
<h2><span class="header-section-number">6.2</span> Optimising the code</h2>
<p>It is time for a short technical digression. You may have noticed that running the function <code>multiple_traits_2()</code> it is quite time consuming with a population of 1000 individuals. There is a quick way to check the exact time needed, using the function <code>Sys.time()</code>, which return your system current time. Let’s run the function again and calcualte how long it takes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)
end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
end_time <span class="op">-</span><span class="st"> </span>start_time</code></pre></div>
<pre><code>## Time difference of 49.01696 secs</code></pre>
<p>On a common laptop, it may take more than 30 seconds. To store the output, we are using a tibble with <span class="math inline">\(1100000\)</span> observations, as <em>max_traits</em> is equal to <span class="math inline">\(1100\)</span>, which needs to be updated, in the right position, at each generation. A possiblity to speed up the simulation is to record our output in a different data structure.</p>
<p>So far, we have been using tibbles to store the output. R, as all programming languages, can store data in different structures. Depending on what the data are and on what one wants to do with them, different structures can be more or less suitable. So far, we used tibbles for the important data of our simulations, such as <code>population</code> or <code>output</code>. Tibbles can have heterogeneous data, depending on what we need to store: for example, in our <code>output</code> tibble, the <span class="math inline">\(trait\)</span> column was spacified as a factor, whereas the others two columns, <span class="math inline">\(generation\)</span> and <span class="math inline">\(p\)</span>, were numeric.</p>
<p>An alternative is to use vectors—and matrices, which can be thought as 2-dimensional vectors— that are basic structures in R. Differently from tibbles, in a matrix all data should be of the same type, in our case numeric (so we need to be careful to remember what numbers represent), but they may be convenient to use as the calculations performed on them are efficient, so that when we run models that are more complicated, or when we will need to produce bigger outputs, our simulations will still be relatively fast.</p>
<p>We can rewrite a function that runs exactly the same simulation, but using matrices instead of tibbles. The output is now a matrix with <span class="math inline">\(t_\text{max}\)</span> rows and <em>max_traits</em> columns, intialised with NAs at the beginning, and the population is a vector of integers, representing the trait for each individual.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multiple_traits_matrix &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max, mu) {
  
  max_traits &lt;-<span class="st"> </span>N <span class="op">+</span><span class="st"> </span>N <span class="op">*</span><span class="st"> </span>mu <span class="op">*</span><span class="st"> </span>t_max
  
  output &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA</span>, <span class="dt">nrow =</span> t_max, <span class="dt">ncol =</span> max_traits)
  
  <span class="co"># create first generation</span>
  population &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  output[<span class="dv">1</span>, ] &lt;-<span class="st"> </span><span class="kw">hist</span>(population, <span class="dv">0</span><span class="op">:</span>max_traits, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density
  
  <span class="co"># add first generation&#39;s p for all traits</span>
  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {
    last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) <span class="co"># record what is the last trait introduced in the population</span>
  
    previous_population &lt;-<span class="st"> </span>population <span class="co"># copy individuals to previous_population tibble</span>
    
    population &lt;-<span class="st"> </span><span class="kw">sample</span>(previous_population, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
    <span class="co"># randomly copy from previous generation</span>
    
    innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) <span class="co"># select the innovators</span>
    <span class="cf">if</span> ((last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="op">&lt;</span><span class="st"> </span>max_traits) {
      population[innovators] &lt;-<span class="st"> </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="co"># replace innovators&#39; traits with new traits</span>
    }
    
    output[t, ] &lt;-<span class="st"> </span><span class="kw">hist</span>(population, <span class="dv">0</span><span class="op">:</span>max_traits, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>density <span class="co"># get p for all traits and put it into output slot for this generation t</span>
  }
  output <span class="co"># export data</span>
}</code></pre></div>
<p>To plot the output, we re-transform it in a tibble, so that can be handled by <code>ggplot()</code>. In order to do this, we first create a column that explicitly indicates the number of generations, and then we use the function <code>gather()</code> to reassemble the columns of the matrix in key-value pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plot_multiple_traits_matrix &lt;-<span class="st"> </span><span class="cf">function</span>(data_model) {
  generation &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(data_model)[<span class="dv">1</span>], <span class="kw">dim</span>(data_model)[<span class="dv">2</span>])
  data_to_plot &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(data_model) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">gather</span>( <span class="dt">key =</span> <span class="st">&quot;trait&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;p&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">add_column</span>(generation)
  <span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">y =</span> p, <span class="dt">x =</span> generation)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> trait)) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>)
}</code></pre></div>
<p>We can now run the function calculating the time needed, and then plot the results, to see if they look the same.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_matrix</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)
end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">plot_multiple_traits_matrix</span>(data_model)</code></pre></div>
<pre><code>## Warning: `as_tibble.matrix()` requires a matrix with column names or a `.name_repair` argument. Using compatibility `.name_repair`.
## This warning is displayed once per session.</code></pre>
<p><img src="_main_files/figure-html/7.16-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">end_time <span class="op">-</span><span class="st"> </span>start_time</code></pre></div>
<pre><code>## Time difference of 0.872508 secs</code></pre>
<p>The results are equivalent, and the simulations is almost 100 times faster! This shows that implementation details are very important when building individual based models. When one needs to run several times the same simulation, or testing many different parameter values, implementation choices can make drastic differences.</p>
</div>
<div id="the-distribution-of-popularity" class="section level2">
<h2><span class="header-section-number">6.3</span> The distribution of popularity</h2>
<p>An interesting aspect of these simulations is that, even if all traits are equal and individuals are not biased, few traits, for random reasons, are more successful than the majority of the others. A way to visualise this is to plot their cumulative popularity, that is the sums of their quantities over all generations. Given our matrix, it is easy to calculate them by summing each column and multiplying by <em>N</em> (remember they are frequencies, whereas we want now to visualise their actual quantities).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cumulative &lt;-<span class="st"> </span><span class="kw">colSums</span>(data_model) <span class="op">*</span><span class="st"> </span>N </code></pre></div>
<p>Let’s sort them from the more to the least popular and plot the results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_to_plot &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">cumulative =</span> <span class="kw">sort</span>(cumulative, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>))

<span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">seq_along</span>(cumulative), <span class="dt">y =</span> cumulative)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;trait label&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;cumulative popularity&quot;</span>)</code></pre></div>
<p><img src="_main_files/figure-html/7.18-1.png" width="672" /></p>
<p>This is an example of a long-tailed distribution. The great majority of traits did not spread in the population, and their cumulative popularity is very close to one. Very few of them—the ones on the left side of the plot—were instead succesfull. Long-tailed distributions like the one we just produced are very common for cultural traits: very few movies, books, first names are very popular, while the great majority is not. In addition, in these domains, the popular traits are <em>much</em> more popular than the unpopular ones. The averge cumulative popularity is <code>mean(cumulative)</code>, but the most succesfull trait has a popularity of <code>max(cumulative)</code>.</p>
<p>It is common to plot these distributions by binning the data in intervals of exponentially increasing size. In other words, we want to know how many traits have a cumulative popularity between 1 and 2, than between 2 and 4, than between 4 and 8, and so on, until we reach the maxmimum value of cumulative popularity. The code below does that, using a <code>for</code> cycle find how many traits fall in each bins and further normalising according to bin size. The size is increased 50 times, until an arbitrary maximum bin size of <span class="math inline">\(2^{50}\)</span>, to be sure to include all cumulative popularities. (We will get rid of the empty bins before plotting.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bin &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">50</span>)
x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">50</span>)
<span class="cf">for</span>( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">50</span> ){
  bin[i] &lt;-<span class="st"> </span><span class="kw">sum</span>( cumulative <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>(i<span class="op">-</span><span class="dv">1</span>) <span class="op">&amp;</span><span class="st"> </span>cumulative <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>i)
  bin[i] &lt;-<span class="st"> </span>( bin[i] <span class="op">/</span><span class="st"> </span><span class="kw">length</span>( cumulative ) ) <span class="op">/</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>(i<span class="op">-</span><span class="dv">1</span>);
  x[i] &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">^</span>i
}</code></pre></div>
<p>We can now visualise the data on a log-log plot (after filtering out the empty bins). A log-log plot is a graph that uses logarithmic scales on both axes. Using logarithmic axes is useful when, as in this case, the data are skewed towards large values. In the previous plot, we were not able to appreciate visually any difference in the great majority of data points, for example points that had cumulative popularity between 1 and 10, as they were all tangled close to the x-axis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data_to_plot &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">bin =</span> bin, <span class="dt">x =</span> x) 
data_to_plot &lt;-<span class="st"> </span><span class="kw">filter</span>(data_to_plot, bin <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)

<span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> bin)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;cumulative popularity&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;proportion of traits&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_y_log10</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()</code></pre></div>
<p><img src="_main_files/figure-html/7.20-1.png" width="672" /></p>
<p>In addition, on a log-log scale, the distribution of cumulative popularity produced by unbiased copying lies approximatively on a straigh line (we plotted a linear fitting of the data with the command <code>stat_smooth(method = &quot;lm&quot;)</code>). The goodness of fit and the slope of the line can be used to compare different models of cultural transmission (what would happen with conformity? What with a model bias? And so on…) and to match them with empirical data to develop hypotheses on the processes that generated these distributions in the real world.</p>
</div>
<div id="summary-of-the-model-5" class="section level2">
<h2><span class="header-section-number">6.4</span> Summary of the model</h2>
<p>An interesting insight we have from our simulations is that these extreme distributions do not necessarly result from</p>
<hr />
</div>
<div id="analytical-appendix-6" class="section level2">
<h2><span class="header-section-number">6.5</span> Analytical appendix</h2>
<hr />
</div>
<div id="further-readings-6" class="section level2">
<h2><span class="header-section-number">6.6</span> Further readings</h2>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="horizontal-vertical-and-oblique-transmission-.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>

    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": ["_main.pdf", "_main.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
