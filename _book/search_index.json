[
["group-structured-populations-and-migration.html", "11 Group structured populations and migration 11.1 Summary of the model 11.2 Analytical appendix 11.3 Further reading", " 11 Group structured populations and migration Many simulations assume well-mixed populations, that is, populations of individuals that haven an equal chance of encountering each other. In the previouse chapter, we have looked at the effects of structured interactions on the transmission of cultural traits. Both, structured and unstructued populations, can be good approximations to the real world, depending on the context and research question. In this chapter, we will look at a combination of the two, structured populations. That is, a large population of individuals is divided into subpopulations, where individauls within a subpopulation are equally likely to encounter each other, whereas encounter frequency between subpopulations is significantly reduced. As such learning only occurs within each subpopulation. However, individuals can migrate between subpopulations, bringing along their version of a cultural trait. In this chapter, we will simulate this movement between subpopulations to study its effect on the transmission of a socially acquired behaviour. We model a population of size \\(n\\), with \\(s\\) subpopulations, and \\(b\\) instances of a behavioural trait. For most of this chapter, we assume that there are two versions of the behaviour, for example, two individauls greet each other either with a handshake or with a hug. You will see that there are many opportunities to alter the model (have more subpopulations, behaviours, learning events, etc.). We will start very simply with one large population where individuals acquire a behavioural trait from a random individual in their population, and then add layers to the model. But first, we need to set up the population: n &lt;- 100 b &lt;- 2 behaviours &lt;- sample(x=b, size=n, replace=TRUE) table(behaviours) ## behaviours ## 1 2 ## 46 54 Because we are only interested in which instance of the behaviour an individual expresses, an individual is fully characterised by that behaviour, and so, we can represent the entire population as a vector (behaviours) of expressed behaviours. Now we add a loop to select a random individaul (which is only represented as a behaviour along the poptraits vector) and let this individual copy a random other individual: We will also add a reporting variable to keep an eye on the frequency of traits t &lt;- ntimesteps &lt;- 1000 recbehav &lt;- rectraits &lt;- matrix(NA, nrow=ntimesteps, ncol=nbehaviour) for(timestep in 1:ntimesteps){ # choose a random observer and a random individual to observe observer_model &lt;- sample(x=popsize, size=2, replace=F) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] # record the frequency of each trait in each timestep rectraits[timestep,] &lt;- table(traits) } Let us have a look at the time line for this simulation: library(ggplot2) library(reshape2) rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;behaviour&quot;,&quot;freq&quot;) ggplot(rectraits_d) + geom_line(aes(x=time, y=freq/popsize, col=factor(behaviour))) + scale_y_continuous(limits=c(0,1)) ## Warning: Removed 926 row(s) containing missing values (geom_path). As we have seen in the chapter on unbiased transmission (REF), the frequency of the two traits will move around 0.5. For smaller populations, more traits, or longer time drift will lead to the exclusion of one of the traits. We can test this by using a much smaller population: popsize &lt;- 20 nbehaviour &lt;- 2 ntimesteps &lt;- 1000 migrationModel &lt;- function(POPSIZE, NBEHAVIOUR, NTIMESTEPS){ traits &lt;- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NBEHAVIOUR) for(timestep in 1:NTIMESTEPS){ # choose a random observer and a random individual to observe observer_model &lt;- sample(x=POPSIZE, size=2, replace=F) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] rectraits[timestep,] &lt;- as.numeric(table(traits)) } return(rectraits) } res &lt;- migrationModel(POPSIZE=popsize, NBEHAVIOUR=nbehaviour, NTIMESTEPS=ntimesteps) rectraits_d &lt;- melt(res) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;behaviour&quot;,&quot;freq&quot;) ggplot(rectraits_d) + geom_line(aes(x=time, y=freq/popsize, col=factor(behaviour))) + scale_y_continuous(limits=c(0,1)) Now let us assume that the population we are looking at is subdivided into two clusters. We will keep track which individual belongs to which cluster and then record the frequency of one of the traits (with two traits knowing the frequency of one is telling you the frequency of the other) in each cluster: npop &lt;- 2 popsize &lt;- 100 nbehaviour &lt;- 2 ntimesteps &lt;- 1000 migrationModel &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){ traits &lt;- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE) cluster &lt;- sample(x=NPOP, size=POPSIZE, replace=TRUE) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random observer and a random individual to observe observer_model &lt;- sample(x=POPSIZE, size=2, replace=F) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] rectraits[timestep,] &lt;- c(sum( traits[cluster==1]==1 ) / sum(cluster==1), sum( traits[cluster==2]==1 ) / sum(cluster==2)) } rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;cluster&quot;,&quot;freq&quot;) return(rectraits_d) } res &lt;- migrationModel(NPOP=npop, POPSIZE=popsize, NBEHAVIOUR=nbehaviour, NTIMESTEPS=ntimesteps) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) If you rund this code repeatedly, you will see that on average the frequency of the behaviour will still be around 0.5 and that the frequency in both clusters is correlated. This is what we expect because individuals do not choose one over the other cluster to learn from. With a small change in the line where we record the frequency of traits, we can make this code work for more than two clusters: npop &lt;- 4 popsize &lt;- 100 nbehaviour &lt;- 2 ntimesteps &lt;- 1000 migrationModel &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){ traits &lt;- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE) cluster &lt;- sample(x=NPOP, size=POPSIZE, replace=TRUE) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random observer and a random individual to observe observer_model &lt;- sample(x=POPSIZE, size=2, replace=F) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] rectraits[timestep,] &lt;- unlist(lapply(1:NPOP, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) } rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;cluster&quot;,&quot;freq&quot;) return(rectraits_d) } res &lt;- migrationModel(NPOP=npop, POPSIZE=popsize, NBEHAVIOUR=nbehaviour, NTIMESTEPS=ntimesteps) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) So far, an individual is equally likely to learn from any other individual in the entire population. What would happen if clusters were completely isolated from each other, and so an individaul would only learn from within its cluster? One way to do this is to change the sample function that selects a cultural model. Instead of selecting among all individuals, we limit it to individuals in the same cluster (same cluster ID). In anticipation of migration, let’s also add an if statement to check whether there is any model left in that cluster: npop &lt;- 2 popsize &lt;- 50 nbehaviour &lt;- 2 ntimesteps &lt;- 1000 migrationModel &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){ traits &lt;- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE) cluster &lt;- sample(x=NPOP, size=POPSIZE, replace=TRUE) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random cluster clusterid &lt;- sample(npop, 1) # if there are at least two individuals in this cluster if(sum(cluster==clusterid)&gt;1){ # choose a random observer and a random individual to observe within the same cluster observer_model &lt;- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] } rectraits[timestep,] &lt;- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) } rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;cluster&quot;,&quot;freq&quot;) return(rectraits_d) } res &lt;- migrationModel(NPOP=npop, POPSIZE=popsize, NBEHAVIOUR=nbehaviour, NTIMESTEPS=ntimesteps) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) When you run this simulation repeatedly, you will see that sometimes one of the behaviours gets lost in one, both, or neither of the clusters. Let’s test that these clusters are in fact independent by fixing each population to one of the two behaviours: migrationModel &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS){ traits &lt;- rep(1:NBEHAVIOUR, each=POPSIZE/NPOP) cluster &lt;- rep(1:NPOP, each=POPSIZE/NPOP) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random cluster clusterid &lt;- sample(npop, 1) # if there are at least two individuals in this cluster if(sum(cluster==clusterid)&gt;1){ # choose a random observer and a random individual to observe within the same cluster observer_model &lt;- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] } rectraits[timestep,] &lt;- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) } rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;cluster&quot;,&quot;freq&quot;) return(rectraits_d) } res &lt;- migrationModel(NPOP=2, POPSIZE=50, NBEHAVIOUR=2, NTIMESTEPS=100) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) Now, let us change the code to allow migration between the clusters. real migration (change cluster id) cultural migration (learn from a different cluster also) migrationModel &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS, MIGRATION){ # traits &lt;- sample(x=NBEHAVIOUR, size=POPSIZE, replace=TRUE) # cluster &lt;- sample(x=NPOP, size=POPSIZE, replace=TRUE) traits &lt;- rep(1:NBEHAVIOUR, each=POPSIZE/NPOP) cluster &lt;- rep(sample(NPOP), each=POPSIZE/NPOP) rectraits &lt;- matrix(NA, nrow=NTIMESTEPS, ncol=NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random cluster clusterid &lt;- sample(npop, 1) # if there are at least two individuals in this cluster if(sum(cluster==clusterid)&gt;1){ # choose a random observer and a random individual to observe within the same cluster observer_model &lt;- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] } # migrate if(runif(1,0,1) &lt;= MIGRATION){ cluster[ observer_model[1] ] &lt;- sample(npop, 1) } rectraits[timestep,] &lt;- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) } rectraits_d &lt;- melt(rectraits) colnames(rectraits_d) &lt;- c(&quot;time&quot;, &quot;cluster&quot;,&quot;freq&quot;) return(rectraits_d) } If we leave migration at zero, we still find that the behaviours in the two clusters are independent from each other: res &lt;- migrationModel(NPOP=2, POPSIZE=50, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=0) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) At the other extreme (migration equal to 1), we find that the frequency of the behaviours becomes correlated as more and more individuals keep moving between the clusters. It is as if there were not clusters. res &lt;- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=1) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) For rare migration, we can find occassional changes in the frequency but it usually bounces back. res &lt;- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=0.01) ggplot(res) + geom_line(aes(x=time, y=freq, col=factor(cluster))) + scale_y_continuous(limits=c(0,1)) + ylab(&quot;Relative frequency of behaviour 1&quot;) Now, let’s check how correlated the groups are. To do so, run repeatedly (100) and check correlation between end points of the two populations, do this for different migration rates. repeatedRun &lt;- do.call(&quot;rbind&quot;, lapply(1:100, function(run){ # run individual simulation res &lt;- migrationModel(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=.5) # return only the frequency for each cluster at the last time step resLast &lt;- res[res[,&quot;time&quot;]==max(res[,&quot;time&quot;]),&quot;freq&quot;] return(resLast) }) ) ggplot(as.data.frame(repeatedRun)) + geom_point(aes(x=V1, y=V2)) + xlab(&quot;Frequency in cluster 1&quot;) + ylab(&quot;Frequency in cluster 2&quot;) mean(abs(repeatedRun[,1]-repeatedRun[,2])) ## [1] 0.1245411 let’s change the function so that the model will return the analysis right away migrationModelAnalysed &lt;- function(NPOP, POPSIZE, NBEHAVIOUR, NTIMESTEPS, MIGRATION, REPETITIONS){ rectraitsFreq &lt;- matrix(NA, ncol=NPOP, nrow=REPETITIONS) for(repetitions in 1:REPETITIONS){ traits &lt;- rep(1:NBEHAVIOUR, each=POPSIZE/NPOP) cluster &lt;- rep(sample(NPOP), each=POPSIZE/NPOP) for(timestep in 1:NTIMESTEPS){ # choose a random cluster clusterid &lt;- sample(npop, 1) # if there are at least two individuals in this cluster if(sum(cluster==clusterid)&gt;1){ # choose a random observer and a random individual to observe within the same cluster observer_model &lt;- sample(x=POPSIZE, size=2, replace=F, prob=(cluster==clusterid)*1) # let observer acquire trait from model traits[ observer_model[1] ] &lt;- traits[ observer_model[2] ] } # migrate if(runif(1,0,1) &lt;= MIGRATION){ cluster[ observer_model[1] ] &lt;- sample(npop, 1) } } rectraitsFreq[repetitions, ] &lt;- unlist(lapply(1:npop, function(x) sum( traits[cluster==x]==1 ) / sum(cluster==x))) } return( data.frame(migration=MIGRATION, # rsq = cor(x=rectraitsFreq[,1], y=rectraitsFreq[,2])^2, absdiff = mean(abs(rectraitsFreq[,1]-rectraitsFreq[,2]))) ) } migrationModelAnalysed(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=.125, REPETITIONS=2) ## migration absdiff ## 1 0.125 0.2723705 Now we can easily run this simulation for various different values of migration rates repeatedRun &lt;- do.call(&quot;rbind&quot;, lapply(seq(from=0, to=1, by=0.05), function(migration){ # lapply(runif(n=50, min=0, max=1), function(migration){ migrationModelAnalysed(NPOP=2, POPSIZE=100, NBEHAVIOUR=2, NTIMESTEPS=1000, MIGRATION=migration, REPETITIONS=20) }) ) ggplot(repeatedRun) + geom_point(aes(x=migration, y=absdiff)) + xlab(&quot;Migration rate&quot;) + ylab(&quot;Average frequency difference between clusters&quot;) 11.1 Summary of the model This model … Finally, suggest that this model can be extended to accomodate different population structures. Here, we have only looked at symeetric connectiongs between populations (all subpopulations are connected). But the structure could also be a line, a circle, or a star. The only thing we would need to change for that is the probability vector in the sample function of the migration part. Thus, not choosing randomly among all subpopulations, but among those that share a connection with the cluster the individual is in. 11.2 Analytical appendix Todo, or omit. 11.3 Further reading Maybe a simpler example where we have three populations and three behaviours (shake left hand (red), right hand (red), clap both hands together). Individuals are replaced and copy behaviour of the majory of N samples within their group That leads to stable greeting traditions within each group (display populations as network, colour nodes based on behaviour) If we now allow migration (after learning) between groups, stability will depend on strength of migration (if we allowed migrationi before learning then individuals wouldn’t be ‘tradition carrier’) If we go all the way up to migration \\(= 1\\), we find that the subgroups behave like one big group Maybe suggest as additional examples (but not exercise here?): * In addition to A–B, B–C, A–C, we can also test A–B, B–C (line) to see what happens to the fate of the central population with two neighbours * Finally, we can use the same set up (A–B, B–C) with larger flow towards B and less towards C "]
]
