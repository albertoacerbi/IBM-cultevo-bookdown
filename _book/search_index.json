[
["traits-inter-dependence.html", "10 Traits inter-dependence 10.1 Many-traits model 10.2 Summary of the model 10.3 Analytical appendix 10.4 Further readings", " 10 Traits inter-dependence Relationships between traits are important. Examples. Imagine a simple scenario when there are only two possible relationships between traits (compatible or incompatible), they are simmetric (if A is compatible with B, also B will be compatible with A). Each trait is compatible with itself. Traits A B C D A +1 +1 -1 -1 B +1 +1 -1 -1 C -1 -1 +1 +1 D -1 -1 +1 +1 Have a look at the world library(tidyverse) set.seed(111) my_world &lt;- matrix(c(1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1), nrow = 4, ncol = 4) my_world ## [,1] [,2] [,3] [,4] ## [1,] 1 1 -1 -1 ## [2,] 1 1 -1 -1 ## [3,] -1 -1 1 1 ## [4,] -1 -1 1 1 Function for the simulation traits_inter_dependence &lt;- function(N, t_max, k, mu, p_death, world){ output &lt;- tibble(trait = as.factor(rep(1:4, each = t_max)), generation = rep(1:t_max, 4), p = rep(NA, t_max * 4)) population &lt;- matrix(0, ncol = 4, nrow = N) output[output$generation == 1 ,]$p &lt;- colSums(population) / N for(t in 2:t_max){ # innovations innovators &lt;- sample(c(TRUE, FALSE), N, prob = c(mu, 1 - mu), replace = TRUE) innovations &lt;- sample(1:4, sum(innovators), replace = TRUE) population[cbind(which(innovators == TRUE), innovations)] &lt;- 1 # copying demonstrators &lt;- sample(1:N, replace = TRUE) demonstrators_traits &lt;- sample(1:4, N, replace = TRUE) for(i in 1:N){ if(population[demonstrators[i], demonstrators_traits[i]]){ compatibility_score &lt;- sum(world[demonstrators_traits[i], which(population[i,]&gt;0)]) copy &lt;- (1 / (1 + exp(-k*compatibility_score))) &gt; runif(1) if(copy){ population[i,demonstrators_traits[i]] &lt;- 1 } } } # birth/death replace &lt;- sample(c(TRUE, FALSE), N, prob = c(p_death, 1 - p_death), replace = TRUE) population[replace, ] &lt;- 0 output[output$generation == t ,]$p &lt;- colSums(population) / N } output } data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) check that are the compatible traits data_model[data_model$generation==1000,] ## # A tibble: 4 x 3 ## trait generation p ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 1000 0.04 ## 2 2 1000 0.03 ## 3 3 1000 0.91 ## 4 4 1000 0.92 It varies at each simulation. What happens by changing the world? (remember you can visualise the matrix) my_world &lt;- matrix(c(1,1,1,-1, 1,1,1,-1,1,1,1,-1,-1,-1,-1,1), nrow = 4, ncol = 4) data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) All compatible: my_world &lt;- matrix(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1), nrow = 4, ncol = 4) data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) No compatiblity equates to a random copy (remember the logistic) 10.1 Many-traits model 10.2 Summary of the model 10.3 Analytical appendix 10.4 Further readings "],
["references.html", "11 References", " 11 References "]
]
