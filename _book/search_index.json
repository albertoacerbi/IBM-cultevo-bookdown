[
["traits-inter-dependence.html", "10 Traits inter-dependence 10.1 Compatible and incompatible traits 10.2 Many-traits model 10.3 Summary of the model 10.4 Analytical appendix 10.5 Further readings", " 10 Traits inter-dependence In real life, the relationship a cultural trait has with other, coexisting, cultural traits, is important to determine its success. Nails will enjoy much cultural success in a world where hammers are present, and less in a world where they are not. Being against abortion in contemporary US is strongly correlated to being religious, which, in turn, is (less strongly) correlated with not supporting same-sex marriage. Of course, not all these relationships are stable in time, and they can also be themselves subject to cultural change. In this chapter, we will explore how simple relationships between traits can be modeled, and how they can influence cultural evolution. 10.1 Compatible and incompatible traits We can start by assuming that, when an observer meets a demonstrator, the observer evaluates the relationships of the traits of the demonstrator with its own traits, and use this information to decide whether to copy or not. For example, if the observer has the trait “being religious” and the demonstrator the trait “being pro abortion”, copying will be less likely to happen than if the demonstrator has the trait “being against abortion”. We can imagine a simple scenario when there are only two possible relationships between two traits: they are compatible, meaning that the presence of one trait will reinforce the presence of the other, or incompatible, meaning the opposite. In addition, the relationship is symmetric: if trait A favours B, also trait B favours A, and the same holds for incompatibility. Finally, we assume that each trait is compatible with itself, simply meaning that, if the observer has trait A and the demonstrator has trait A too, this will increase the probability that copy will happens. We can represent the relationships between traits, in a simple “world” with only four traits, with a symmetric matrix, as the one below, where \\(+1\\) denotes compatibility, and \\(-1\\) denotes incompatibility. Traits A B C D A +1 +1 -1 -1 B +1 +1 -1 -1 C -1 -1 +1 +1 D -1 -1 +1 +1 In this case, the traits A and B are compatible with themselves, but incompatible with C and D, and the same happens for C and D, that are compatible with themselves, but incompatible with A and B. We can build manually the same matrix in R, by indicating one-by-one the values we want to fill in, and the number of rows and columns the matrix needs to have. As usual, we can check that we did right asking to print the matrix, by writing its name. library(tidyverse) set.seed(111) my_world &lt;- matrix(c(1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1), nrow = 4, ncol = 4) my_world ## [,1] [,2] [,3] [,4] ## [1,] 1 1 -1 -1 ## [2,] 1 1 -1 -1 ## [3,] -1 -1 1 1 ## [4,] -1 -1 1 1 Given this simple way of representing a “world” of compatibilities among traits, we can write our model. traits_inter_dependence &lt;- function(N, t_max, k, mu, p_death, world){ output &lt;- tibble(trait = rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;), each = t_max), generation = rep(1:t_max, 4), p = rep(NA, t_max * 4)) population &lt;- matrix(0, ncol = 4, nrow = N) output[output$generation == 1 ,]$p &lt;- colSums(population) / N for(t in 2:t_max){ # innovations innovators &lt;- sample(c(TRUE, FALSE), N, prob = c(mu, 1 - mu), replace = TRUE) innovations &lt;- sample(1:4, sum(innovators), replace = TRUE) population[cbind(which(innovators == TRUE), innovations)] &lt;- 1 # copying demonstrators &lt;- sample(1:N, replace = TRUE) demonstrators_traits &lt;- sample(1:4, N, replace = TRUE) # not sure how to vectorise the code below. The first &quot;if&quot; can be done with: # population[cbind(demonstrators,demonstrators_traits)]==1 as in previous chapter # but I could not figure out a way to calcualte the compatibility score at popualtion level for(i in 1:N){ if(population[demonstrators[i], demonstrators_traits[i]]){ compatibility_score &lt;- sum(world[demonstrators_traits[i], which(population[i,]&gt;0)]) copy &lt;- (1 / (1 + exp(-k*compatibility_score))) &gt; runif(1) if(copy){ population[i,demonstrators_traits[i]] &lt;- 1 } } } # birth/death replace &lt;- sample(c(TRUE, FALSE), N, prob = c(p_death, 1 - p_death), replace = TRUE) population[replace, ] &lt;- 0 output[output$generation == t ,]$p &lt;- colSums(population) / N } output } As in the previous chapter, the simulation starts with no traits, and individuals introduce them with random innovations, the rate of which is regulated by the parameter \\(\\mu\\). Individuals are replaced by culturally-naive newborns with a probability \\(p_\\text{death}\\). There are, mainly, two differences. One is that the function accepts a parameter, world, a four-by-four matrix of compatibilities between traits (thus the compatibilities can change, but not the actual number of traits). The second is in the copying procedure. As in the previous chapter, one trait is randomly selected in the demonstrator and, if the demonstrator i has it (population[demonstrators[i], demonstrators_traits[i]]), the observer calculates a “compatibility score”. The compatibility score is the sum of the compatibilities of all the traits of the observer towards the traits of the demonstrator, calculated using the “world” matrix. If, for example, both observer and demonstrator have A and B (and only A and B), the compatibility with be \\(2\\), if the observer has A and B and the demonstrator C and D, the compatibility with be \\(-2\\) and so on. In the following line, the compatibility score is transformed in the actual probability to copy with a logistic function, useful to transform possibly unbounded positive and negative values in values between \\(0\\) and \\(1\\): \\[P_\\text{copy} = \\frac{1}{1 + e^{-kC}} \\hspace{30 mm}(15.1)\\] where C represents the compatibility score between observer and demonstrator, and k is a parameter of the simulation, that regulates how steep is the logistic, that is, how fast positive values of the compatibility score produce a probability to copy equal to \\(1\\), and negative values a probability equal to \\(0\\). We can now run the function, using the plot_multiple_traits() function to plot the result. We use a value of \\(k=10\\), and a small probability of innovation \\(\\mu=0.0005\\), so that the dynamics are mainly generated by cultural transmission. my_world &lt;- matrix(c(1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1), nrow = 4, ncol = 4) data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) Two of the four traits diffuse in the population. We can check whether these are in fact one of the couple of compatible traits, having a look at the last line of the output produced by the simulation. data_model[data_model$generation==1000,] ## # A tibble: 4 x 3 ## trait generation p ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 A 1000 0.04 ## 2 B 1000 0.03 ## 3 C 1000 0.91 ## 4 D 1000 0.92 They are indeed trait C and D. If you run the simulation other times the results are likely to change, with sometime A and B being the successful traits, but it will be practically impossible that one or three traits will be successful, with this “world” of compatibilities. What does it happen, however, if we change the world? We can run a new simulation where the traits A, B, and C are all compatible, but not D (remember, you can visualise the matrix of compatibilities by typing its name to be sure to have entered the compatibilities correctly). my_world &lt;- matrix(c(1,1,1,-1, 1,1,1,-1,1,1,1,-1,-1,-1,-1,1), nrow = 4, ncol = 4) data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) As expected, now three traits have high frequencies in the population, while one is unsuccessful. As before, you can check that the unsuccessful trait is actually D by inspecting manually the last line of the output. Not surprisingly, if all traits are compatible, they all spread equally in the population. my_world &lt;- matrix(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1), nrow = 4, ncol = 4) data_model &lt;- traits_inter_dependence(N = 100, t_max = 1000, k = 10, mu = 0.0005, p_death = 0.01, world = my_world) plot_multiple_traits(data_model) Notice that the opposite—when none of the traits is compatible with each other—is an extreme case that produces a situation similar to the unbiased transmission model with multiple traits we explored earlier in the book. Individuals only copy once in their life, when they do not have any trait, and they copy whatever trait they observe with 50% probability, since a compatibility score of \\(0\\) while always produce \\(0.5\\) when transformed by the logistic function. After that, any encounter will produce a very low probability of copying (when they meet demonstrators with any other trait), or a high, but useless, probability (when they meet a demonstrator with the same trait they already have). 10.2 Many-traits model Building the compatibility world by hand is unpractical, especially if we want to test our model with more traits. We will now extend the basic model above in order to be able to customise the maximum number of traits and to generate automatically the compatibility worlds. M &lt;- 7 gamma &lt;- 0.5 my_world &lt;- matrix( rep(1, M * M), nrow = M) compatibilities &lt;- sample(c(1, -1), choose(M, 2), prob = c(gamma, 1 - gamma), replace = TRUE) my_world[upper.tri(my_world)] &lt;- compatibilities my_world &lt;- t(my_world) my_world[upper.tri(my_world)] &lt;- compatibilities We have now two parameters we use to build the matrix: one (\\(M\\)) gives the maximum number of traits, and the other (\\(\\gamma\\), or gamma in the code) gives the probability that two traits are compatible with each other. To build the matrix, we first create a \\(M\\) by \\(M\\) matrix of all ones, then a vector of compatibilities randomly generated with probability \\(\\gamma\\) (the length of the vector is the number of entries above the main diagonal of the matrix, given by choose(M, 2)), and finally we copy these values in the upper and lower triangle of the matrix (to make it symmetric, in practice, we copy it twice in the upper triangle, transposing the matrix after the first copy). Here the matrix we generated. my_world ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 -1 -1 -1 -1 1 -1 ## [2,] -1 1 1 1 1 1 -1 ## [3,] -1 1 1 -1 1 -1 -1 ## [4,] -1 1 -1 1 1 -1 1 ## [5,] -1 1 1 1 1 -1 1 ## [6,] 1 1 -1 -1 -1 1 1 ## [7,] -1 -1 -1 1 1 1 1 The function to run the simulation is very similar to the previous one, once we account for the difference in how the compatibility world is created, and the two new parameters (\\(M\\) and \\(\\gamma\\)) needed in the function call. Another difference is that the output data structure is a matrix and not a tibble. Since we want to be able to run the simulations with an arbitrary high number of traits, we need to speed up the computation, exactly in the same way we did for the multiple traits model in chapter 7. traits_inter_dependence_2 &lt;- function(N, M, t_max, k, mu, p_death, gamma){ output &lt;- matrix(data = NA, nrow = t_max, ncol = M) # initalise the traits&#39; world: world &lt;- matrix( rep(1, M * M), nrow = M) compatibilities &lt;- sample(c(1, -1), choose(M,2), prob = c(gamma, 1 - gamma), replace = TRUE) world[upper.tri(world)] &lt;- compatibilities world &lt;- t(world) world[upper.tri(world)] &lt;- compatibilities # initialise the population: population &lt;- matrix(0, ncol = M, nrow = N) output[1, ] &lt;- colSums(population) / N for(t in 2:t_max){ # innovations innovators &lt;- sample(c(TRUE, FALSE), N, prob = c(mu, 1 - mu), replace = TRUE) innovations &lt;- sample(1:M, sum(innovators), replace = TRUE) population[cbind(which(innovators == TRUE), innovations)] &lt;- 1 # copying demonstrators &lt;- sample(1:N, replace = TRUE) demonstrators_traits &lt;- sample(1:M, N, replace = TRUE) for(i in 1:N){ if(population[demonstrators[i], demonstrators_traits[i]]){ compatibility_score &lt;- sum(world[demonstrators_traits[i], which(population[i,]&gt;0)]) copy &lt;- (1 / (1 + exp(-k*compatibility_score))) &gt; runif(1) if(copy){ population[i,demonstrators_traits[i]] &lt;- 1 } } } # birth/death replace &lt;- sample(c(TRUE, FALSE), N, prob = c(p_death, 1 - p_death), replace = TRUE) population[replace, ] &lt;- 0 output[t, ] &lt;- colSums(population) / N } output } We can now use the plot_multiple_traits_matrix() function we wrote in chapter 7 to visualise the results of the model. We can have a look at what happens with 20 traits, and an intermediate probability of compatibility. data_model &lt;- traits_inter_dependence_2(N = 100, M = 20, t_max = 2000, k = 10, mu = 0.001, p_death = 0.01, gamma = .5) plot_multiple_traits_matrix(data_model) data_model &lt;- traits_inter_dependence_2(N = 100, M = 20, t_max = 2000, k = 10, mu = 0.001, p_death = 0.01, gamma = 1) plot_multiple_traits_matrix(data_model) r_max = 10 test_inter_dependence &lt;- tibble(gamma = rep(seq(0, 1, by = .1), r_max), run = as.factor(rep(1:r_max, each = 11)), C = NA) for(condition in seq(0, 1, by = .1)){ for(r in 1:r_max) { data_model &lt;- traits_inter_dependence_2(N = 100, M = 20, t_max = 2000, k = 10, mu = 0.001, p_death = 0.01, gamma = condition) test_inter_dependence[test_inter_dependence$gamma == condition &amp; test_inter_dependence$run == r, ]$C &lt;- sum(data_model[2000,]&gt;.5) } } ggplot(data = test_inter_dependence, aes(x = gamma, y = C)) + geom_jitter(width = 0, height = 0.5, alpha = 0.5) + stat_summary(fun.y = mean, geom = &quot;point&quot;, colour = &quot;red&quot;) + stat_summary(fun.y = mean, geom = &quot;line&quot;, colour = &quot;red&quot;) + theme_bw() + labs(x = &quot;Average compatibility&quot;, y = &quot;C (number of common traits)&quot;) 10.3 Summary of the model Mention the logistic, and the last visualisation 10.4 Analytical appendix 10.5 Further readings "],
["references.html", "11 References", " 11 References "]
]
