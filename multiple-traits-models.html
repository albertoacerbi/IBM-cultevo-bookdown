<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Multiple traits models | 07-Multiple_traits_models.utf8</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.19 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Multiple traits models | 07-Multiple_traits_models.utf8" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Multiple traits models | 07-Multiple_traits_models.utf8" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Individual-based models of cultural evolution</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path=""><a href="#multiple-traits-models"><i class="fa fa-check"></i><b>1</b> Multiple traits models</a><ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#unbiased-transmission-with-multiple-traits"><i class="fa fa-check"></i><b>1.1</b> Unbiased transmission with multiple traits</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#introducing-innovation"><i class="fa fa-check"></i><b>1.2</b> Introducing innovation</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#optimising-the-code"><i class="fa fa-check"></i><b>1.3</b> Optimising the code</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#the-distribution-of-popularity"><i class="fa fa-check"></i><b>1.4</b> The distribution of popularity</a></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#summary-of-the-model"><i class="fa fa-check"></i><b>1.5</b> Summary of the model</a></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#further-readings"><i class="fa fa-check"></i><b>1.6</b> Further readings</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="multiple-traits-models" class="section level1">
<h1><span class="header-section-number">1</span> Multiple traits models</h1>
<p>In all previous models, individuals could possess one of only two cultural traits, <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>. This is a useful simplification, and it represents cases in which cultural traits can be modeled as binary choices, such as voting Republican or Democrat, driving on the left or the right, or being vegetarian or meat-eating. In other cases, however, there are many options: in many countries there are multiple political parties to vote for, there may be many dietary choices (vegan, pescatarian, vegetarian, etc), and so on. What happens when we copy others’ choices given more than two alternatives? To simplify this question, we again assume unbiased copying as in the [first chapter][Unbiased transmission]: all traits are functionally equivalent and other individuals are copied at random.</p>
<div id="unbiased-transmission-with-multiple-traits" class="section level2">
<h2><span class="header-section-number">1.1</span> Unbiased transmission with multiple traits</h2>
<p>The first modification we need to make in the code concerns how traits are represented. Since we have an undetermined number of possible traits we cannot use the two letters <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Instead we will use numbers, referring to trait “1”, trait “2”, trait “3”, etc. How can we distribute the traits in the initial population? We can assume that there are <span class="math inline">\(m\)</span> possible traits at the beginning, with <span class="math inline">\(m \leq N\)</span> (as usual, <span class="math inline">\(N\)</span> is the population size). In all the following simulations, we will fix <span class="math inline">\(m=N\)</span>, and effectively initialise each individual with a trait randomly chosen between “1” and “100”.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2"></a>N &lt;-<span class="st"> </span><span class="dv">100</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span></code></pre></div>
<p>You can inspect the <code>population</code> tibble by writing its name.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>population</span></code></pre></div>
<pre><code>## # A tibble: 100 x 1
##    trait
##    &lt;int&gt;
##  1    14
##  2    15
##  3    73
##  4    10
##  5    74
##  6    75
##  7    83
##  8    80
##  9    92
## 10    31
## # … with 90 more rows</code></pre>
<p>The basic code of the simulation is similar to the code in the [first chapter][Unbiased transmission], but what should the <code>output</code> be? Until now, we generally just needed to save the frequency of one of the two traits, because the frequency of the other was always one minus the first’s frequency. Now we need the frequencies of all <span class="math inline">\(N\)</span> traits. (Technically, we only need to track <span class="math inline">\(N-1\)</span> frequencies, with the last inferred by substracting the other frequencies from 1. But for simplicity we’ll track all of the frequencies.)</p>
<p>Second, how do we measure the frequency of the traits in each generation? The base R function <code>tabulate()</code> does this for us. <code>tabulate()</code> counts the number of times each element of a vector (<code>population$trait</code> in our case) occurs in the bins that we also pass to the function. In our case the bins are <span class="math inline">\(1\)</span> to <span class="math inline">\(N\)</span>. Since we want the frequencies, and not the absolute number, we divide the result by <span class="math inline">\(N\)</span>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>multiple_traits &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max) {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  </span>
<span id="cb4-3"><a href="#cb4-3"></a>  output &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">as.factor</span>(<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>N, <span class="dt">each =</span> t_max)), </span>
<span id="cb4-4"><a href="#cb4-4"></a>                   <span class="dt">generation =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>t_max, N), </span>
<span id="cb4-5"><a href="#cb4-5"></a>                   <span class="dt">p =</span> <span class="kw">as.numeric</span>(<span class="kw">rep</span>(<span class="ot">NA</span>, t_max <span class="op">*</span><span class="st"> </span>N)))</span>
<span id="cb4-6"><a href="#cb4-6"></a>  </span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="co"># Create first generation</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>  population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  </span>
<span id="cb4-9"><a href="#cb4-9"></a>  </span>
<span id="cb4-10"><a href="#cb4-10"></a>  <span class="co"># Add first generation&#39;s p for all traits</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>  output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">tabulate</span>(population<span class="op">$</span>trait, <span class="dt">nbins =</span> N) <span class="op">/</span><span class="st"> </span>N  </span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {</span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="co"># copy individuals to previous_population tibble</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    previous_population &lt;-<span class="st"> </span>population </span>
<span id="cb4-16"><a href="#cb4-16"></a>    </span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="co"># Randomly copy from previous generation</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span>
<span id="cb4-19"><a href="#cb4-19"></a>    </span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="co"># Get p for all traits and put it into output slot for this generation t</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>    output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span>t, ]<span class="op">$</span>p &lt;-<span class="st"> </span><span class="kw">tabulate</span>(population<span class="op">$</span>trait, <span class="dt">nbins =</span> N) <span class="op">/</span><span class="st"> </span>N  </span>
<span id="cb4-22"><a href="#cb4-22"></a>  }</span>
<span id="cb4-23"><a href="#cb4-23"></a>  <span class="co"># Export data from function</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>  output </span>
<span id="cb4-25"><a href="#cb4-25"></a>}</span></code></pre></div>
<p>Finally, the function to plot the output is similar to what we have already done when plotting multiple runs. The one difference is that now the colored lines do not represent different runs, but different traits, as indicated below by <code>aes(colour = trait)</code>. The new line <code>theme(legend.position = "none")</code> simply tells ggplot to not include the legend in the graph, as it is not informative. It would just show 100 colors, one for each trait.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>plot_multiple_traits &lt;-<span class="st"> </span><span class="cf">function</span>(data_model) {</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="kw">ggplot</span>(<span class="dt">data =</span> data_model, <span class="kw">aes</span>(<span class="dt">y =</span> p, <span class="dt">x =</span> generation)) <span class="op">+</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> trait)) <span class="op">+</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="st">    </span><span class="kw">ylim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="op">+</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>)</span>
<span id="cb5-7"><a href="#cb5-7"></a>}</span></code></pre></div>
<p>As usual, we can call the function and see what happens:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">200</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">plot_multiple_traits</span>(data_model)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.5-1.png" alt="With small populations, the majority of traits disappear after few generations in a model with multiple traits and unbiased transmission." width="672" />
<p class="caption">
(#fig:7.5)With small populations, the majority of traits disappear after few generations in a model with multiple traits and unbiased transmission.
</p>
</div>
<p>Usually, only one or two traits are still present in the population after 200 generations, and, if we increase <span class="math inline">\(t_\text{max}\)</span> for example to 1000, virtually all runs end up with only a single trait reaching fixation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">plot_multiple_traits</span>(data_model)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.6-1.png" alt="With small populations, a single traits reach fixation if there are enough generations in a model with multiple traits and unbiased transmission." width="672" />
<p class="caption">
(#fig:7.6)With small populations, a single traits reach fixation if there are enough generations in a model with multiple traits and unbiased transmission.
</p>
</div>
<p>This is similar to what we saw with only two traits, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>: with unbiased copying and relatively small populations, drift is a powerful force and quickly erodes cultural diversity.</p>
<p>As we already discussed, increasing <span class="math inline">\(N\)</span> reduces the effect of drift. You can experiment with various values for <span class="math inline">\(N\)</span> and <span class="math inline">\(t_\text{max}\)</span>. However, the general point is that variation is gradually lost in all cases. How can we counterbalance the homogenizing effect that drift has in small and isolated population, such as the one we are simulating?</p>
</div>
<div id="introducing-innovation" class="section level2">
<h2><span class="header-section-number">1.2</span> Introducing innovation</h2>
<p>One option is to introduce new traits via innovation. We can imagine that, at each time step, a proportion of individuals, <span class="math inline">\(\mu\)</span>, introduces a new trait in the population. We use the same notation that we used for mutation in [chapter 2][Unbiased and biased mutation]: you can think that ‘mutation’ is when an individual change its trait for one that is already present, whereas an ‘innovation’ happens when an individual introduces a new trait never seen before. The remaining proportion of individuals, <span class="math inline">\(1-\mu\)</span>, copy at random from others, as before. We can start with a small value, such as <span class="math inline">\(\mu=0.01\)</span>. Since <span class="math inline">\(N=100\)</span>, this means that in each generation, on average, one new trait will be introduced into the population.</p>
<p>The following code adds innovation to the multiple-trait code from above:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>mu &lt;-<span class="st"> </span><span class="fl">0.01</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"># Record the last trait introduced in the population</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) </span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co"># Copy the population tibble to previous_population tibble</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>previous_population &lt;-<span class="st"> </span>population </span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"># Randomly copy from previous generation</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  </span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co"># Identify the innovators</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) </span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co"># if there are innovators</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="cf">if</span>( <span class="kw">sum</span>(innovators) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){ </span>
<span id="cb8-12"><a href="#cb8-12"></a>  <span class="co"># Replace innovators&#39; traits with new traits</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>  population[innovators,]<span class="op">$</span>trait &lt;-<span class="st"> </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) </span>
<span id="cb8-14"><a href="#cb8-14"></a>}</span></code></pre></div>
<p>There are two modifications here. First, we need to select who are the innovators. For that, we use again the function <code>sample()</code>, biased by <span class="math inline">\(\mu\)</span>, picking <code>TRUE</code> (corresponding to being an innovator) or <code>FALSE</code> (keeping the copied cultural trait) <span class="math inline">\(N\)</span> times.</p>
<p>Second, we need to actually introduce the new traits, with the correct number labels. First we record at the beginning of each generation the label of the last trait introduced (at the beginning, with <span class="math inline">\(N=100\)</span>, it will likely be 100 because we initialise each individual’s traits by choosing randomly between 1 and 100). When new traits are introduced, we give them consecutive number labels: the first new trait will be called 101, the second 102, and so on. The code above adds all of the new traits into the innovator slots all in one go, which is more efficient than doing it one innovator at a time.</p>
<p>We can now, as usual, wrap everything in a function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>multiple_traits_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max, mu) {</span>
<span id="cb9-2"><a href="#cb9-2"></a>  max_traits &lt;-<span class="st"> </span>N <span class="op">+</span><span class="st"> </span>N <span class="op">*</span><span class="st"> </span>mu <span class="op">*</span><span class="st"> </span>t_max</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>  output &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">as.factor</span>(<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>max_traits, <span class="dt">each =</span> t_max)), </span>
<span id="cb9-5"><a href="#cb9-5"></a>                   <span class="dt">generation =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span>t_max, max_traits), </span>
<span id="cb9-6"><a href="#cb9-6"></a>                   <span class="dt">p =</span> <span class="kw">as.numeric</span>(<span class="kw">rep</span>(<span class="ot">NA</span>, t_max <span class="op">*</span><span class="st"> </span>max_traits)))</span>
<span id="cb9-7"><a href="#cb9-7"></a>  </span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="co"># Create first generation</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>  population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  </span>
<span id="cb9-10"><a href="#cb9-10"></a>  <span class="co"># Add first generation&#39;s p for all traits</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>  output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]<span class="op">$</span>p &lt;-<span class="st"> </span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="st">    </span><span class="kw">tabulate</span>(population<span class="op">$</span>trait, <span class="dt">nbins =</span> max_traits) <span class="op">/</span><span class="st"> </span>N  </span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a>  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {</span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="co"># Record what is the last trait introduced in the population</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>    last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) </span>
<span id="cb9-17"><a href="#cb9-17"></a>    </span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span class="co"># Copy individuals to previous_population tibble</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>    previous_population &lt;-<span class="st"> </span>population </span>
<span id="cb9-20"><a href="#cb9-20"></a>    </span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="co"># Randomly copy from previous generation</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>    population &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">trait =</span> <span class="kw">sample</span>(previous_population<span class="op">$</span>trait, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>))  </span>
<span id="cb9-23"><a href="#cb9-23"></a>    </span>
<span id="cb9-24"><a href="#cb9-24"></a>    <span class="co"># Select the innovators</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>    innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) </span>
<span id="cb9-26"><a href="#cb9-26"></a>    <span class="cf">if</span> ((last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="op">&lt;</span><span class="st"> </span>max_traits) {  </span>
<span id="cb9-27"><a href="#cb9-27"></a>      <span class="cf">if</span>(<span class="kw">sum</span>(innovators) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb9-28"><a href="#cb9-28"></a>        <span class="co"># Replace innovators&#39; traits with new traits</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>        population[innovators,]<span class="op">$</span>trait &lt;-<span class="st"> </span></span>
<span id="cb9-30"><a href="#cb9-30"></a><span class="st">          </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) </span>
<span id="cb9-31"><a href="#cb9-31"></a>      }</span>
<span id="cb9-32"><a href="#cb9-32"></a>    }</span>
<span id="cb9-33"><a href="#cb9-33"></a>    <span class="co"># Get p for all traits and put it into output slot for this generation t</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>    output[output<span class="op">$</span>generation <span class="op">==</span><span class="st"> </span>t, ]<span class="op">$</span>p &lt;-<span class="st"> </span></span>
<span id="cb9-35"><a href="#cb9-35"></a><span class="st">      </span><span class="kw">tabulate</span>(population<span class="op">$</span>trait, <span class="dt">nbins =</span> max_traits) <span class="op">/</span><span class="st"> </span>N </span>
<span id="cb9-36"><a href="#cb9-36"></a>  }</span>
<span id="cb9-37"><a href="#cb9-37"></a>  <span class="co"># Export data</span></span>
<span id="cb9-38"><a href="#cb9-38"></a>  output </span>
<span id="cb9-39"><a href="#cb9-39"></a>}</span></code></pre></div>
<p>You should now be familiar with more or less everything within this function, with one exception: the new quantity <em>max_traits</em>. This is a trick we are using to avoid making the code too slow to run. Our <code>output</code> tibble, as you remember, records all the frequencies of all traits. When programming, a good rule-of-thumb is to avoid dynamically modifying the size of your data structures, such as adding new rows to a pre-existing tibble during the simulation. Where possible, set the size of a data structure at the start, and then modify its values during the simulation. So rather than creating a tibble that is expanded dynamically as new traits are introduced via innovation, we create a bigger tibble from the start. How big should it be? We do not know for sure, but a good estimate is that we will need space for the initial traits (<span class="math inline">\(N\)</span>), plus around <span class="math inline">\(N\mu\)</span> traits that are added each generation.</p>
<p>To be absolutely sure we do not exceed this estimate, we wrap the innovation instruction within the <code>if ((last_trait + sum(innovators)) &lt; max_traits)</code> condition. This prevents innovation when the tibble has filled up. This might prevent innovation in the last few generations, but this should have negligible consequences for our purposes.</p>
<p>Let’s now run the function with an innovation rate <span class="math inline">\(\mu=0.01\)</span>, a population of 100 individuals, and for 200 generations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">200</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">plot_multiple_traits</span>(data_model)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.9-1.png" alt="By adding innovations, more traits can be preserved in the population." width="672" />
<p class="caption">
(#fig:7.9)By adding innovations, more traits can be preserved in the population.
</p>
</div>
<p>With innovation, there should now be more traits at non-zero frequency at the end of the simulation than when innovation was not possible. We can check the exact number, by inspecting how many frequencies are higher than 0 in the last row of our matrix:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">sum</span>(<span class="kw">filter</span>(data_model, generation<span class="op">==</span><span class="dv">200</span>)<span class="op">$</span>p <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 7</code></pre>
<p>What happens if we increase the number of generations, or time steps, to 1000, as we did before?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">plot_multiple_traits</span>(data_model)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.11-1.png" alt="By adding innovations, traits are preserved even when the model runs for several generations." width="672" />
<p class="caption">
(#fig:7.11)By adding innovations, traits are preserved even when the model runs for several generations.
</p>
</div>
<p>As you can see in the plot, there should still be several traits that have frequencies higher than 0, even after 1000 generations. Again, we can find the exact number in the final generation:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">sum</span>(<span class="kw">filter</span>(data_model, generation<span class="op">==</span><span class="dv">1000</span>)<span class="op">$</span>p <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 9</code></pre>
<p>Innovation, in sum, allows the maintenance of variation even in small populations.</p>
</div>
<div id="optimising-the-code" class="section level2">
<h2><span class="header-section-number">1.3</span> Optimising the code</h2>
<p>Now for a short technical digression. You may have noticed that running the function <code>multiple_traits_2()</code> is quite time consuming with a population of 1000 individuals. There is a quick way to check the exact time needed, using the function <code>Sys.time()</code>. This returns the current time at the point of its execution. Let’s run the function again and calculate how long it takes.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb16-2"><a href="#cb16-2"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_2</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a>end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb16-4"><a href="#cb16-4"></a>end_time <span class="op">-</span><span class="st"> </span>start_time</span></code></pre></div>
<pre><code>## Time difference of 23.62713 secs</code></pre>
<p>While this varies from computer to computer, it may take several seconds to finsh. To store the output, we are using a tibble with <span class="math inline">\(1100000\)</span> data points, as <em>max_traits</em> is equal to <span class="math inline">\(1100\)</span>, which needs to be updated in each of the <span class="math inline">\(1000\)</span> generations. One way of speeding up the simulation is to record our output in a different data structure.</p>
<p>So far, we have been using tibbles to store our simulation output. R, as with all programming languages, can store data in different structures. Depending on what the data are and what one wants to do with them, different structures are more or less suitable. The advantage of tibbles is that they can contain heterogeneous data, depending on what we need to store: for example, in our <code>output</code> tibble, the <code>trait</code> column was specified as a factor, whereas the others two columns, <code>generation</code> and <code>p</code>, were numeric.</p>
<p>An alternative is to use vectors and matrices. A vector is a list of data points that are all of the same type, e.g. logical (TRUE/FALSE), integer (whole numbers), numeric (any numbers), or character (text). Matrices are just two-dimensional vectors: they must also contain all the same type of data, but they have rows and columns similar to a tibble, dataframe or Excel spreadsheet. The advantage of vectors and matrices is efficiency: they make simulations much faster than identical code running with tibbles.</p>
<p>Let’s rewrite our multiple trait function that runs exactly the same simulation, but using matrices instead of tibbles. The output is now a matrix with <code>t_max</code> rows and <code>max_traits</code> columns. This is initialised with NAs at the beginning. The population is a vector of integers, representing the trait held by each individual.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>multiple_traits_matrix &lt;-<span class="st"> </span><span class="cf">function</span>(N, t_max, mu) {</span>
<span id="cb18-2"><a href="#cb18-2"></a>  </span>
<span id="cb18-3"><a href="#cb18-3"></a>  max_traits &lt;-<span class="st"> </span>N <span class="op">+</span><span class="st"> </span>N <span class="op">*</span><span class="st"> </span>mu <span class="op">*</span><span class="st"> </span>t_max</span>
<span id="cb18-4"><a href="#cb18-4"></a>  </span>
<span id="cb18-5"><a href="#cb18-5"></a>  output &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA</span>, <span class="dt">nrow =</span> t_max, <span class="dt">ncol =</span> max_traits)</span>
<span id="cb18-6"><a href="#cb18-6"></a>  </span>
<span id="cb18-7"><a href="#cb18-7"></a>  <span class="co"># Create first generation</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>  population &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>N, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>)</span>
<span id="cb18-9"><a href="#cb18-9"></a>  output[<span class="dv">1</span>, ] &lt;-<span class="st"> </span><span class="kw">tabulate</span>(population, <span class="dt">nbins =</span> N) <span class="op">/</span><span class="st"> </span>N</span>
<span id="cb18-10"><a href="#cb18-10"></a>  </span>
<span id="cb18-11"><a href="#cb18-11"></a>  <span class="co"># Add first generation&#39;s p for all traits</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>  <span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>t_max) {</span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="co"># Record what is the last trait introduced in the population</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>    last_trait &lt;-<span class="st"> </span><span class="kw">max</span>(population) </span>
<span id="cb18-15"><a href="#cb18-15"></a>    </span>
<span id="cb18-16"><a href="#cb18-16"></a>    <span class="co"># Copy individuals to previous_population tibble</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>    previous_population &lt;-<span class="st"> </span>population </span>
<span id="cb18-18"><a href="#cb18-18"></a>    </span>
<span id="cb18-19"><a href="#cb18-19"></a>    <span class="co"># Randomly copy from previous generation</span></span>
<span id="cb18-20"><a href="#cb18-20"></a>    population &lt;-<span class="st"> </span><span class="kw">sample</span>(previous_population, N, <span class="dt">replace =</span> <span class="ot">TRUE</span>)</span>
<span id="cb18-21"><a href="#cb18-21"></a>    </span>
<span id="cb18-22"><a href="#cb18-22"></a>    <span class="co"># Select the innovators</span></span>
<span id="cb18-23"><a href="#cb18-23"></a>    innovators &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), N, <span class="dt">prob =</span> <span class="kw">c</span>(mu, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mu), <span class="dt">replace =</span> <span class="ot">TRUE</span>) </span>
<span id="cb18-24"><a href="#cb18-24"></a>    <span class="cf">if</span> ((last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) <span class="op">&lt;</span><span class="st"> </span>max_traits) {</span>
<span id="cb18-25"><a href="#cb18-25"></a>      <span class="co"># Replace innovators&#39; traits with new traits</span></span>
<span id="cb18-26"><a href="#cb18-26"></a>      population[innovators] &lt;-<span class="st"> </span>(last_trait <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span>(last_trait <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(innovators)) </span>
<span id="cb18-27"><a href="#cb18-27"></a>    }</span>
<span id="cb18-28"><a href="#cb18-28"></a>    <span class="co"># Get p for all traits and put it into output slot for this generation t</span></span>
<span id="cb18-29"><a href="#cb18-29"></a>    output[t, ] &lt;-<span class="st"> </span><span class="kw">tabulate</span>(population, <span class="dt">nbins =</span> max_traits) <span class="op">/</span><span class="st"> </span>N </span>
<span id="cb18-30"><a href="#cb18-30"></a>  }</span>
<span id="cb18-31"><a href="#cb18-31"></a>  <span class="co"># Export data</span></span>
<span id="cb18-32"><a href="#cb18-32"></a>  output </span>
<span id="cb18-33"><a href="#cb18-33"></a>}</span></code></pre></div>
<p>To plot the output, we re-convert it into a tibble so that it can be handled by <code>ggplot()</code>. We first create a column that explicitly indicates the number of generations, and then we use the function <code>gather()</code> from the tidyverse to reassemble the columns of the matrix in key-value pairs.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>plot_multiple_traits_matrix &lt;-<span class="st"> </span><span class="cf">function</span>(data_model) {</span>
<span id="cb19-2"><a href="#cb19-2"></a>  generation &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(data_model)[<span class="dv">1</span>], <span class="kw">dim</span>(data_model)[<span class="dv">2</span>])</span>
<span id="cb19-3"><a href="#cb19-3"></a>  </span>
<span id="cb19-4"><a href="#cb19-4"></a>  data_to_plot &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(data_model) <span class="op">%&gt;%</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="st">    </span><span class="kw">gather</span>(<span class="dt">key =</span> <span class="st">&quot;trait&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;p&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="st">    </span><span class="kw">add_column</span>(generation)</span>
<span id="cb19-7"><a href="#cb19-7"></a>  </span>
<span id="cb19-8"><a href="#cb19-8"></a>  <span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">y =</span> p, <span class="dt">x =</span> generation)) <span class="op">+</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> trait)) <span class="op">+</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="st">    </span><span class="kw">ylim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="op">+</span></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span></span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>)</span>
<span id="cb19-13"><a href="#cb19-13"></a>}</span></code></pre></div>
<p>We can now run the new function, checking that it gives the same output as the tibble version, and again calculating the time needed.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb20-2"><a href="#cb20-2"></a>data_model &lt;-<span class="st"> </span><span class="kw">multiple_traits_matrix</span>(<span class="dt">N =</span> <span class="dv">100</span>, <span class="dt">t_max =</span> <span class="dv">1000</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a>end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">plot_multiple_traits_matrix</span>(data_model)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.16-1.png" alt="We obtain qualitatively the same results of the previous code, in a model with unbiased transmission, multiple traits, and innovation." width="672" />
<p class="caption">
(#fig:7.16)We obtain qualitatively the same results of the previous code, in a model with unbiased transmission, multiple traits, and innovation.
</p>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>end_time <span class="op">-</span><span class="st"> </span>start_time</span></code></pre></div>
<pre><code>## Time difference of 0.04507589 secs</code></pre>
<p>The results are equivalent, but the simulation should be hundreds of times faster! This shows that implementation details are very important when building individual based models. When one needs to run the same simulation many times, or test many different parameter values, implementation choices can make drastic differences.</p>
</div>
<div id="the-distribution-of-popularity" class="section level2">
<h2><span class="header-section-number">1.4</span> The distribution of popularity</h2>
<p>An interesting aspect of these simulations is that, even if all traits are functionally equivalent and transmission is unbiased, a few traits, for random reasons, are more successful than the others. A way to visualise this is to plot their cumulative popularity, i.e. the sum of their quantities over all generations. Given our matrix, it is easy to calculate this by summing each column and multiplying by <em>N</em> (remember they are frequencies, whereas now we want to visualise their actual quantities). We also need to keep only the values that are higher than zero: values equal to zero are in fact the empty slots created in the initial matrix that were never filled with actual traits.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>cumulative &lt;-<span class="st"> </span><span class="kw">colSums</span>(data_model) <span class="op">*</span><span class="st"> </span>N </span>
<span id="cb23-2"><a href="#cb23-2"></a>cumulative &lt;-<span class="st"> </span>cumulative[cumulative <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>]</span></code></pre></div>
<p>Let’s sort them from the most to the least popular and plot the results.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>data_to_plot &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">cumulative =</span> <span class="kw">sort</span>(cumulative, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>))</span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">seq_along</span>(cumulative), <span class="dt">y =</span> cumulative)) <span class="op">+</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="st">  </span><span class="kw">theme_bw</span>() <span class="op">+</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;trait label&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;cumulative popularity&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.18-1.png" alt="The popularity distribution of traits with unbiased copying is long-tailed, with few very successful traits and many relatively unsuccessful ones." width="672" />
<p class="caption">
(#fig:7.18)The popularity distribution of traits with unbiased copying is long-tailed, with few very successful traits and many relatively unsuccessful ones.
</p>
</div>
<p>This is an example of a long-tailed distribution. The great majority of traits did not spread in the population, and their cumulative popularity is very close to one. Very few of them—the ones on the left side of the plot—were instead very successful. Long-tailed distributions like the one we just produced are very common for cultural traits: a small number of movies, books, or first names are very popular, while the great majority is not. In addition, in these domains, the popular traits are <em>much</em> more popular than the unpopular ones. The average cumulative popularity of the data we plotted is 105.87, but the most successful trait has a popularity of 13434.</p>
<p>It is common to plot these distributions by binning the data in intervals of exponentially increasing size. In other words, we want to know how many traits have a cumulative popularity between 1 and 2, then between 2 and 4, then between 4 and 8, and so on, until we reach the maximum value of cumulative popularity. The code below does that, using a <code>for</code> cycle to find how many traits fall in each bin and further normalising according to bin size. The size is increased 50 times, until an arbitrary maximum bin size of <span class="math inline">\(2^{50}\)</span>, to be sure to include all cumulative popularities.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>bin &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">50</span>)</span>
<span id="cb25-2"><a href="#cb25-2"></a>x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">50</span>)</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="cf">for</span>( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">50</span> ){</span>
<span id="cb25-4"><a href="#cb25-4"></a>  bin[i] &lt;-<span class="st"> </span><span class="kw">sum</span>( cumulative <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>(i<span class="dv">-1</span>) <span class="op">&amp;</span><span class="st"> </span>cumulative <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>i)</span>
<span id="cb25-5"><a href="#cb25-5"></a>  bin[i] &lt;-<span class="st"> </span>( bin[i] <span class="op">/</span><span class="st"> </span><span class="kw">length</span>( cumulative ) ) <span class="op">/</span><span class="st"> </span><span class="dv">2</span><span class="op">^</span>(i<span class="dv">-1</span>);</span>
<span id="cb25-6"><a href="#cb25-6"></a>  x[i] &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">^</span>i</span>
<span id="cb25-7"><a href="#cb25-7"></a>}</span></code></pre></div>
<p>We can now visualise the data on a log-log plot, after filtering out the empty bins. A log-log plot is a graph that uses logarithmic scales on both axes. Using logarithmic axes is useful when, as in this case, the data are skewed towards large values. In the previous plot, we were not able to appreciate visually any difference in the great majority of data points, for example points that had cumulative popularity between 1 and 10, as they were all bunched up close to the x-axis.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>data_to_plot &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">bin =</span> bin, <span class="dt">x =</span> x) </span>
<span id="cb26-2"><a href="#cb26-2"></a>data_to_plot &lt;-<span class="st"> </span><span class="kw">filter</span>(data_to_plot, bin <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="kw">ggplot</span>(<span class="dt">data =</span> data_to_plot, <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> bin)) <span class="op">+</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;cumulative popularity&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;proportion of traits&quot;</span>) <span class="op">+</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="st">  </span><span class="kw">scale_y_log10</span>() <span class="op">+</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="st">  </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>) <span class="op">+</span></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure">
<img src="07-Multiple_traits_models_files/figure-html/7.20-1.png" alt="Popularity distribution of traits on a log-log scale." width="672" />
<p class="caption">
(#fig:7.20)Popularity distribution of traits on a log-log scale.
</p>
</div>
<p>On a log-log scale, the distribution of cumulative popularity produced by unbiased copying lies approximately on a straight line (this linear best-fit line is produced using the command <code>stat_smooth(method = "lm")</code>). This straight line on a log-log plot is known as a “power law” frequency distribution. The goodness of fit and the slope of the line can be used to compare different types of cultural transmission. For example, what would happen to the above power law if we added some degree of conformity? What about demonstrator-based bias? We can also generate equivalent plots for real-world cultural datasets to test hypotheses about the processes that generated these distributions in the real world.</p>
</div>
<div id="summary-of-the-model" class="section level2">
<h2><span class="header-section-number">1.5</span> Summary of the model</h2>
<p>In this chapter we simulated the case where individuals can possess one of more than two traits. We explored the simplest case of unbiased transmission. We also implemented the possibility of innovation, where individuals introduce, with some probability, new traits into the cultural pool of the population. Individual innovations counterbalance the homogenizing effect of drift, and replace the traits that are gradually lost.</p>
<p>To simulate multiple traits and innovation we also needed to deal with a few technical details such as how to keep track of an initially unknown number of new traits. We learned that it is best to create data structures of the desired size at the outset, rather than changing their size dynamically during the simulation. We also saw the importance of using appropriate data structures when simulations start to become more complex. Replacing tibbles with matrices, we were able to make our simulation 100 times faster.</p>
<p>Our results showed that unbiased copying produces long-tailed distributions where very few traits are very popular and the great majority are not. An interesting insight from this model is that these <code>extreme</code> distributions do not necessarily result from extreme tendencies at the individual level. Some traits become hugely more popular than others without individuals being biased, for example, towards popular traits. Cultural transmission generates these distributions without biases, but simply because popular traits have the intrinsic advantage of being more likely to be randomly copied. We also introduced a new technique, the log-log plot of binned popularity distributions, to visualise this outcome.</p>
</div>
<div id="further-readings" class="section level2">
<h2><span class="header-section-number">1.6</span> Further readings</h2>
<p><span class="citation">@neiman_stylistic_1995</span> first introduced a model of unbiased copying with multiple traits to explain popularity distributions in assemblages of Neolithic pottery. <span class="citation">@bentley_random_2004</span> elaborated on this idea, presenting a ‘random copying’ model (equivalent to the one developed in this chapter) and comparing the popularity distributions produced with real datasets, including the frequency distributions of first names in the US and the citations of patents. <span class="citation">@mesoudi_random_2009</span> explored how adding transmission biases (e.g. conformity) to the basic model changes the resulting power-law frequency distribution.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
